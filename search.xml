<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue.set的详细分析和数据监测</title>
      <link href="/2023/02/28/cEUIRQynKYWg4IB2/"/>
      <url>/2023/02/28/cEUIRQynKYWg4IB2/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当实现定义好了data里的一组数据或者对象里的属性，后面想要添加新的属性或者新的对象的时候，可以使用Vue.set()</p><p>例如data里的student对象，如果想要添加一个sex属性，想当然可能会使用<code>this.student.sex = &#39;male&#39;</code>这种赋值语句，但是这种赋值语句语句vue不会添加setter和getter函数，便不是响应式的，所以不会在页面中显示出来；可以使用<code>Vue.set(this.student,&#39;sex&#39;,&#39;male&#39;)</code>来进行属性的添加</p><p>Vue.set() 是添加响应式属性<br>target：需要向哪个目标对象添加</p><p>key：需要添加的属性名</p><p>val：需要添加的属性的值</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要向 vm实例对象中添加属性 或 直接向 vm._data 中添加属性<br>说明白点 data里那么多数据， 不能直接添加到data的根路径里，只能用来添加到data里对象的属性里</p><h2 id="对数组的数据监测"><a href="#对数组的数据监测" class="headerlink" title="对数组的数据监测"></a>对数组的数据监测</h2><p>vue规定，数组直接发生数据改变（意思就是直接等）不能调用监控<br>push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>Vue.set() 或 vm.$set()<br>这些api可以调用数据监测，进一步更新到你的页面里</p><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>在数组尾部添加一个数据，返回值是新的长度</p><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>在数组尾部删除一个数据，返回值是数组的最后一个元素</p><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h4><p>删除数组的第一个值，并且返回新的第一个值</p><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h4><p>对数组的开头添加一个或更多元素，并返回新的长度</p><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>splice(index,howmany,item1, …, itemX) 方法向/从数组中添加/删除项目，然后返回被删除的项目<br>第一个参数：表示从哪个索引位置（index）添加/删除元素<br>第二个参数：要删除的项目数量。如果设置为 0，则不会删除项目。<br>第三个参数：可选。向数组添加的新项目</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>原列表进行排序，如果指定参数，则使用比较函数指定的比较函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sortNumber (a, b) &#123;</span><br><span class="line">  return a - b</span><br><span class="line">&#125;</span><br><span class="line">let arr = [10,5,40,25,1000,1]</span><br><span class="line">arr.sort(sortNumber)</span><br><span class="line">console.log(arr) // [1, 5, 10, 25, 40, 1000]</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>反向处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue computed 和watch详细分析与使用</title>
      <link href="/2023/02/28/dNvnVBdwos4VWSrG/"/>
      <url>/2023/02/28/dNvnVBdwos4VWSrG/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>如期名，computed是计算属性，被计算出来的属性<br>官方文档中有这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里好像是method也可以完成需求，但是computed具有缓存属性，多次调用，vue会判断computed的依赖值是否修改，如果没有修改则只执行一次，后面会沿用这个结果；但是method是调用一次就会直接执行，造成资源浪费</p><p>computed监控的是自己定义的变量，比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化。这里的这个总金额使用computed属性来进行计算是最好的选择。</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch主要是用来监控vue实例的变化，watch监视的数据必须在data里定义<br>watch只能用来监听一个对象或者一个值，无法监控对象的一个属性<br>watch 不支持缓存，数据变，直接会触发相应的操作<br>watch 支持异步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue常用指令、事件修饰符和自定义指令</title>
      <link href="/2022/09/29/4SHM2ptWgjuslFop/"/>
      <url>/2022/09/29/4SHM2ptWgjuslFop/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="常用指令及作用"><a href="#常用指令及作用" class="headerlink" title="常用指令及作用"></a>常用指令及作用</h2><p><code>v-on</code> 用来给目标元素绑定事件的，事件的类型由参数决定。接下来，将举一个v-on用法的小例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;clickHandler&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>当然 这里一般简写成 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;clickHandler&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><code>v-bind</code> 用来给属性绑定一个变量 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el:&#x27;.app&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        url:&quot;https://www.baidu.com&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a v-bind:href=&quot;url&quot;&gt;click me&lt;/a&gt;</span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure><p>当然也有简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a :href=&quot;url&quot;&gt;click me&lt;/a&gt;</span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure><p><code>v-model</code> <code>v-if</code> <code>v-show</code> <code>v-for</code> <code>v-else</code> 不解释了 太常用了</p><h2 id="没那么常用的指令和作用"><a href="#没那么常用的指令和作用" class="headerlink" title="没那么常用的指令和作用"></a>没那么常用的指令和作用</h2><p><code>v-text</code> 用来绑定数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这俩显示的效果是一样的，但是v-text会把值的内容拿来替换所有div里的内容，如果div里有东西全部都不显示</p><p><code>v-html</code>  绑定数据 和v-text的区别就是v-html可以解析标签<br>安全性问题：容易被利用进行跨站脚本攻击</p><p><code>v-cloak</code> 配合css，可以做到延迟加载并且不会出现插值语法</p><p><code>v-once</code> 只加载一次 后面插值语法内容更新的时候不会发生改变，即只更新一次</p><p><code>v-pre</code> 跳过vue节点的编译过程</p><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>1.prevent 阻止默认事件<br>2.stop 阻止事件冒泡<br>3.once 事件只触发一次<br>4.capture 使用事件的捕获形式<br>5.self 只有event.target是当前元素时才触发事件<br>6.passive 事件的默认行为立即执行，无需等待回调或执行完毕</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><p>写个例子，看看就懂了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-big=&quot;n&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            n:1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">        big(element,binding)&#123;</span><br><span class="line">            element.innerText = binding.value*10</span><br><span class="line">            //element是元素，即dom节点</span><br><span class="line">            //binding是绑定，一般使用binding.value 获取绑定的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>指令所在的模板被重新解析的时候就会重新调用指令</p><h3 id="对象式"><a href="#对象式" class="headerlink" title="对象式"></a>对象式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input fbind:value=&quot;n&quot;&gt;&lt;/input&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            n:1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">        fbind:&#123;</span><br><span class="line">            bind(element,binding)&#123;</span><br><span class="line">                //这里写绑定时需要进行的动作</span><br><span class="line">            &#125;</span><br><span class="line">            insert(element,binding)&#123;</span><br><span class="line">                //插入元素时需要进行的动作</span><br><span class="line">            &#125;</span><br><span class="line">            update(element,binding)&#123;</span><br><span class="line">                //更新时进行的动作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE中key的处理</title>
      <link href="/2022/09/27/5gPRXWxmruWJqCeQ/"/>
      <url>/2022/09/27/5gPRXWxmruWJqCeQ/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="列表中使用key"><a href="#列表中使用key" class="headerlink" title="列表中使用key"></a>列表中使用key</h2><p>key是vue将虚拟dom转化为真实dom的时候会把vue处理掉，所以看不见key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &#123;&#123;p.name&#125;&#125; -- &#123;&#123;p.age&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果需要在person数组里前面添加一个数据，因为下标发生了改变，会发生数据错乱。</p><h2 id="key的工作原理-和-diff算法"><a href="#key的工作原理-和-diff算法" class="headerlink" title="key的工作原理 和 diff算法"></a>key的工作原理 和 diff算法</h2><p>对于初始数据 {id:’001’,name:’张3’,age:’18’},{id:’002’,name:’张4’,age:’18’},{id:’003’,name:’张5’,age:’18’}<br>vue在拿到后生成了虚拟dom如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&quot;0&quot;&gt;张3-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;1&quot;&gt;张4-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;2&quot;&gt;张5-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure><p>数据添加在数组头的时候，现在的数据是：<br>{id:’004’,name:’张2’,age:’18’}<br>{id:’001’,name:’张3’,age:’18’}<br>{id:’002’,name:’张4’,age:’18’}<br>{id:’003’,name:’张5’,age:’18’}</p><p>生成的新虚拟dom为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&quot;0&quot;&gt;张2-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;1&quot;&gt;张3-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;2&quot;&gt;张4-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;3&quot;&gt;张5-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure><p>但是vue不会直接将虚拟dom转化成真实dom，vue将新虚拟dom和旧的虚拟dom进行对比，通俗来讲流程是这样的：<br>首先看新的虚拟dom的key=0的一行，发现key为0，回去旧dom判断key=0的是否存在，而这里是存在的；再观察dom里有两个节点，一个文本（张3-18）,一个input框，文本对比张3-18和张2-18，发现发生了改变，于是vue拿新数据覆盖了旧数据； 对比input节点发现一样（因为输入的数据在真实dom里，现在比对的是虚拟dom，在内存中）；<br>对于对比结果不一致的，于是决定不复用；对于对比结果一致的，直接复用。</p><h2 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h2><p>key是虚拟dom对象的标识，当状态中的数据发生变化的时候，vue会根据新数据生成新的虚拟dom，随后vue进行新的虚拟dom与旧的虚拟dom的对比，按照规则去和留。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM</title>
      <link href="/2022/07/26/M8GXOdNaXupXHGTA/"/>
      <url>/2022/07/26/M8GXOdNaXupXHGTA/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>定义：Document Object Model，文档对象模型。<br>用途：使用JS操作web页面。<br>Document –&gt; 文档表示的是整个html网页文档<br>Object   –&gt; 将网页中的每一个部分都转化成了对象，例如标签，内容，都可以是对象。<br>Model    –&gt; 使用面向对象的方式操作对象</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>定义：node - 构成HTML文档最基本的单元<br>常用有四类：<br> -文档节点：整个HTML文档<br> -元素节点：HTML文档中的HTML标签<br> -属性节点：元素的属性 例如id name<br> -文本节点：HTML标签中的文本内容</p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;这是一个按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dom = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">    //修改按钮文字</span><br><span class="line">    dom.innerHTML = &quot;这是修改过的按钮&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义正则表达式</title>
      <link href="/2022/07/26/lGbgvQJRtplLyffx/"/>
      <url>/2022/07/26/lGbgvQJRtplLyffx/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="创建自定义正则表达式"><a href="#创建自定义正则表达式" class="headerlink" title="创建自定义正则表达式"></a>创建自定义正则表达式</h2><p>判断字符串里是否有aaa</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = /aaa/</span><br><span class="line">console.log(reg.test(&#x27;abc&#x27;)) //false</span><br></pre></td></tr></table></figure><p>如果字符太长，会影响整体美观，可以使用{num}来代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reg = /a&#123;3&#125;/ //判断是否有3个a</span><br><span class="line">var reg1 = /ab&#123;3&#125;/ //判断是否有abbb</span><br><span class="line">var reg2 = /(ab)&#123;3&#125;/ //判断是否有ababab</span><br><span class="line">var reg3 = /ab&#123;1,3&#125;/ 判断是否有1个a+1到3个b</span><br><span class="line">var reg4 = /ab&#123;3, &#125;/判断是否有1个a+3个以上的b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(reg.test(&#x27;abc&#x27;)) //false</span><br></pre></td></tr></table></figure><h3 id="检查是否由哪个字母开头或者结尾"><a href="#检查是否由哪个字母开头或者结尾" class="headerlink" title="检查是否由哪个字母开头或者结尾"></a>检查是否由哪个字母开头或者结尾</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^a/ //以a开头</span><br><span class="line">var reg = /a$/ //以a结尾</span><br><span class="line">var reg = /^a$/ //以a开头且以这个a结尾 换句话说是完全匹配正则表达式</span><br><span class="line">var reg = /^[0-9]/ //以数字开头 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap6 路由</title>
      <link href="/2022/07/12/CD636bLcU1pXCKer/"/>
      <url>/2022/07/12/CD636bLcU1pXCKer/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>在新建组件的时候选择add route 此时会发现多了一个app-routing.module，在这个文件里引入我们声明的其他组件，并且配置路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routes: Routes = [</span><br><span class="line"></span><br><span class="line">    //格式是path:&#x27;路径名&#x27;,component:组件名</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        path:&#x27;home&#x27;,component:HomeComponent</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        path:&#x27;news&#x27;,component:NewsComponent</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        path:&#x27;product&#x27;,component:ProductComponent</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        path:&#x27;**&#x27;,//任意的路由，如果前面的都不能匹配，则和这个匹配</span><br><span class="line">        redirectTo:&#x27;homes&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置路由后,在根组件下会有一个route-outlet的标签，此时我们访问/home时，home组件的内容就会出现在这个route-outlet标签里。<strong>换句话说，你路由到哪个组件，组件内容就会在根组件的route-outlet的位置显示。</strong></p><h4 id="使用a标签跳转"><a href="#使用a标签跳转" class="headerlink" title="使用a标签跳转"></a>使用a标签跳转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装snippet之后直接输入ng-routelink就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a routeLink=&quot;/home&quot;&gt;首页&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="实现选中特效"><a href="#实现选中特效" class="headerlink" title="实现选中特效"></a>实现选中特效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a routeLink=&quot;/home&quot; routeLinkActive=&quot;className&quot;&gt;首页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//.css</span><br><span class="line">.className&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由传值和动态路由"><a href="#路由传值和动态路由" class="headerlink" title="路由传值和动态路由"></a>路由传值和动态路由</h2><h4 id="Get传值"><a href="#Get传值" class="headerlink" title="Get传值"></a>Get传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//A页面跳转到B页面</span><br><span class="line"></span><br><span class="line">//A页面的html</span><br><span class="line">//跳转到aid为key的页面</span><br><span class="line">&lt;a routeLink=&quot;/newsDetail&quot; [queryParams]=&quot;&#123;aid:key&#125;&quot;&gt;跳转到新闻详情&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//B页面接收值</span><br><span class="line">import &#123; ActiveRoute &#125; from &#x27;@angular/route&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constructor(public route:ActiveRoute)&#123;&#125;</span><br><span class="line"></span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">    this.route.queryParams.subscribe((result)=&gt;&#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态路由传值"><a href="#动态路由传值" class="headerlink" title="动态路由传值"></a>动态路由传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//路由配置页</span><br><span class="line">path:&#x27;newsDetail/:aid&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//A页面的html</span><br><span class="line">&lt;a routeLink=&quot;[&#x27;/newsDetail/&#x27;,key]&quot;&gt;跳转到新闻详情&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//B页面的ts</span><br><span class="line"> this.route.params.subscribe((result)=&gt;&#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JS跳转"><a href="#JS跳转" class="headerlink" title="JS跳转"></a>JS跳转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router &#125; from &#x27;@angular/router&#x27;</span><br><span class="line"></span><br><span class="line">this.router.navigate([&#x27;/newsdetail/&#x27;, &#x27;1234&#x27;])</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap5 与服务器交互</title>
      <link href="/2022/07/11/MaeISxN72jT02Gci/"/>
      <url>/2022/07/11/MaeISxN72jT02Gci/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="使用get请求数据"><a href="#使用get请求数据" class="headerlink" title="使用get请求数据"></a>使用get请求数据</h2><p>首先在app.module中引入httpClientModule,然后在imports中声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; httpClientModule &#125; from &#x27;@angular/common/http&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imports:[</span><br><span class="line">    HttpClientModule</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>再在需要使用请求数据的地方引入httpclient与调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HttpClient &#125; from &#x27;@angular/common/http&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constructor(public http:HttpClient)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData()&#123;</span><br><span class="line">    let api = &#x27;xxx&#x27;</span><br><span class="line">    this.http.get(api).subscribe((result)=&gt;&#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用POST提交数据"><a href="#使用POST提交数据" class="headerlink" title="使用POST提交数据"></a>使用POST提交数据</h2><p>大体和GET相同，但是POST需要多引入一个httpheader头文件,因为在进行POST请求的时候需要同时传一个header</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POSTDATA()&#123;</span><br><span class="line">    let api = &#x27;xxx&#x27;</span><br><span class="line">    const httpOptions = &#123;headers: new HttpHeaders(&#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;&#125;)&#125;</span><br><span class="line">    this.http.post(api,&#123;&quot;username&quot;:&quot;123&quot;,&quot;age&quot;:&quot;12&quot;&#125;,httpOptions).subscribe((response)=&gt;&#123;</span><br><span class="line">        console.log(response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用jsonp获取服务器数据"><a href="#使用jsonp获取服务器数据" class="headerlink" title="使用jsonp获取服务器数据"></a>使用jsonp获取服务器数据</h2><p>如果存在跨域，就使用jsonp来获取服务器数据。</p><p>首先，为什么会存在跨域？比如说域名是localhost，使用的协议是https，端口是5777，访问127.0.0.1:3000的服务器就会产生跨域。如果服务器不支持跨域，那么发出的GET或者POST请求都不可以获取到数据。<strong>只要协议、端口、域名有一个不一样，就属于不同源，那么访问时就可能产生跨域问题。</strong></p><p>这里使用的解决方案是使用jsonp解决跨域问题<br>解决的原理：jsonp相当于是通过callback的xxx方法把服务器的数据传回本地</p><p>如何判断服务器支不支持jsonp？<br>在接口后写个callback = xxx 如果显示出了:xxx 说明支持jsonp</p><ol><li>在app.module里引入 httpClientjsonModule</li><li>如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let api = &#x27;xx&#x27;</span><br><span class="line">this.http.jsonp(api,&#x27;callback&#x27;).subscribe((result)=&gt;&#123;</span><br><span class="line">    console.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用axios-第三方-来请求数据"><a href="#使用axios-第三方-来请求数据" class="headerlink" title="使用axios(第三方)来请求数据"></a>使用axios(第三方)来请求数据</h2><p>通过npm安装<br><code>npm install axios --save</code><br><code>import &#123;axios&#125; from &#39;axios&#39;</code><br>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axiosGet(api)&#123;</span><br><span class="line"></span><br><span class="line">    //异步拿数据</span><br><span class="line">    axios.get(api)</span><br><span class="line">    .then(function (response)  &#123;</span><br><span class="line">        console.log(response)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记  --Chap4 生命周期函数与异步编程</title>
      <link href="/2022/07/11/XugN5JDCzLhCKw0b/"/>
      <url>/2022/07/11/XugN5JDCzLhCKw0b/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p> 生命周期函数就是在组件的状态发生改变，例如创建、更新、销毁时调用的一系列方法。Angular创建一个组件时，会调用如下的函数</p><ul><li>constructor()        : 使用简单的值对局部变量进行初始化，注意，这个函数并非生命周期函数</li><li>ngOnchange()         : Angular接受数据绑定时调用 </li><li>ngOnInit()           : Angular第一次显示数据绑定和设置指令/组件的输入属性后调用。一般请求数据放在这里</li><li>ngDocheck()          : 检测,在变更周期中调用。</li><li>ngAfterViewInit()    : 初始化完视图之后调用。做dom操作可以放在这里。</li><li>ngAfterViewChecked() : 视图变更后调用</li><li>ngDestroy()          : 组件销毁时调用</li></ul><h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>ngOnchange()在有父子传值的时候才会触发，如果没有父子组件通讯，ngOnchange()不会触发。<br>几个check函数在数据绑定之后会再触发一次，举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ts文件</span><br><span class="line">public title:any = &#x27;这是一个title&#x27;;</span><br></pre></td></tr></table></figure><p>在视图加载后进行title的数据绑定，会再触发一次三个check函数。所以如果console一下就可以发现，声明周期函数除了Onchange没触发一外全部触发一次之后，三个check函数还会再触发一次。中途如果数据改变了，几个check函数也会触发。</p><h2 id="RXJS异步"><a href="#RXJS异步" class="headerlink" title="RXJS异步"></a>RXJS异步</h2><p>Angular引入RXJS的目的就是为了让异步变简单</p><h4 id="使用observable"><a href="#使用observable" class="headerlink" title="使用observable"></a>使用observable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let stream = new Observable(observer =&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        observer.next(&#x27;get timeout data&#x27;);</span><br><span class="line">    &#125;,2000)</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">stream.subscribe(value =&gt;&#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看上去和promise十分相似，实际上rxjs的功能更加强大。</p><h4 id="超时取消订阅"><a href="#超时取消订阅" class="headerlink" title="超时取消订阅"></a>超时取消订阅</h4><p>使用unsubscribe，超时后取消返回数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GetRxjsData()&#123;</span><br><span class="line">    let stream = new Observable(observer =&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        observer.next(&#x27;get timeout data&#x27;);</span><br><span class="line">    &#125;,2000)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var stream = this.getRxjsData()</span><br><span class="line">var d = stream.subscribe((data)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        d.unsubscribe();</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="反复调用"><a href="#反复调用" class="headerlink" title="反复调用"></a>反复调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getRxjsIntervalData()&#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    return new Observable(observer =&gt;&#123;</span><br><span class="line">        setInterval(()=&gt;&#123;</span><br><span class="line">            var name = &#x27;good&#x27;+count;</span><br><span class="line">            observer.next(name)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(this.getRxjsIntervalData())</span><br></pre></td></tr></table></figure><h2 id="Rxjs中的工具函数–map-amp-filter"><a href="#Rxjs中的工具函数–map-amp-filter" class="headerlink" title="Rxjs中的工具函数–map&amp;filter"></a>Rxjs中的工具函数–map&amp;filter</h2><p>首先安装rxjs模块和导入map,filter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install rxjs-compat</span><br><span class="line">import &#123;map,filter&#125; from &#x27;rxjs/operators&#x27;;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出可以被2整除的value</span><br><span class="line">getRxjsIntervalData()&#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    return new Observable(observer =&gt;&#123;</span><br><span class="line">        setInterval(()=&gt;&#123;</span><br><span class="line">            var name = &#x27;good&#x27;+count;</span><br><span class="line">            observer.next(name)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stream = this.getRxjsIntervalData()</span><br><span class="line">stream.pipe(</span><br><span class="line">    filter(val=&gt;val%2 == 0)).subscribe(value=&gt;&#123;</span><br><span class="line">    console.log(&quot;filter&quot;+value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream.pipe(</span><br><span class="line">    map(value=&gt;&#123;</span><br><span class="line">    return value*value;</span><br><span class="line">&#125;)</span><br><span class="line">).subscribe(value=&gt;&#123;</span><br><span class="line">    console.log(&quot;map&quot;+value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap 3 Dom操作与父子组件通讯</title>
      <link href="/2022/07/08/xnZVKaU9ygUYNAn2/"/>
      <url>/2022/07/08/xnZVKaU9ygUYNAn2/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Dom操作"><a href="#Dom操作" class="headerlink" title="Dom操作"></a>Dom操作</h2><p>Angular中也可以对dom进行操作</p><h4 id="使用原生js方法"><a href="#使用原生js方法" class="headerlink" title="使用原生js方法"></a>使用原生js方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;div id=&quot;box1&quot;&gt;1234&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//ts 将id为box1的颜色变为红色</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    var boxDom:any = document.getElementById(&#x27;box1&#x27;)</span><br><span class="line">    boxDom.style.color = red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Angular自带的dom操作"><a href="#使用Angular自带的dom操作" class="headerlink" title="使用Angular自带的dom操作"></a>使用Angular自带的dom操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//html</span><br><span class="line">&lt;div #Box1&gt;</span><br><span class="line">    我是一个叫做Box1的DOM节点</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//ts</span><br><span class="line"></span><br><span class="line">//头文件先引入</span><br><span class="line">import &#123; viewchild &#125; from &#x27;@angular/core&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在constructor上面构造</span><br><span class="line"></span><br><span class="line">@viewChild(&#x27;Box1&#x27;)Mybox:any;</span><br><span class="line"></span><br><span class="line">//还是在视图加载后的生命周期函数里进行dom操作，因为视图加载后dom才加载完成</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    console.log(this.Mybox)</span><br><span class="line">    //把box1的字体颜色变成红色</span><br><span class="line">    this.Mybox.nativeElement.style.color = &quot;red&quot;;</span><br><span class="line">    //打印dom节点</span><br><span class="line">    console.log(this.Mybox.nativeElement.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上，viewchild是父子组件之间通讯使用的工具，可以使用viewchild对子组件的方法进行访问</p><h2 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h2><h4 id="父组件使用viewchild调用子组件里的方法"><a href="#父组件使用viewchild调用子组件里的方法" class="headerlink" title="父组件使用viewchild调用子组件里的方法"></a>父组件使用viewchild调用子组件里的方法</h4><p>在使用viewChild对整个子组件进行获取后，直接使用this.xxx就可以对整个子组件进行访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@viewChild(&#x27;Box1&#x27;)Mybox:any;</span><br><span class="line"></span><br><span class="line">//使用getChild函数对子组件的run方法进行访问</span><br><span class="line">getChild()&#123;</span><br><span class="line">    this.Mybox.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父组件给子组件传值，使用input"><a href="#父组件给子组件传值，使用input" class="headerlink" title="父组件给子组件传值，使用input"></a>父组件给子组件传值，使用input</h4><p>父组件<code>(home)</code>在调用子组件<code>(header)</code>的时候将自己的msg传到子组件，子组件再进行调用，例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//home组件的html</span><br><span class="line">//方法也可以直接这样传 [run]=&quot;run&quot; 子组件就可以直接使用run方法了</span><br><span class="line">//甚至可以把整个自己传过去 [home]=&quot;this&quot;</span><br><span class="line">&lt;app-header [title]=&quot;title&quot;&gt;我是header组件，也是子组件&lt;/app-header&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//home组件的ts</span><br><span class="line">public msg:any=&#x27;我是父组件的title&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//header组件的ts 引入input</span><br><span class="line">import &#123; Input &#125; from &#x27;Angular/core&#x27;</span><br><span class="line"></span><br><span class="line">//下面使用input</span><br><span class="line">@input()title:any;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//header组件的html可以直接调用title，在ts里也可以用this直接调用</span><br><span class="line">&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line">//输出我是父组件的title</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web中页面缓存的使用方法</title>
      <link href="/2022/07/08/qDdyTOpLgeugPVyT/"/>
      <url>/2022/07/08/qDdyTOpLgeugPVyT/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>LocalStorage是长期储存数据的方法，它拥有永久的生命周期,除非是主动删除数据,否则就算是关闭页面,localStorage保存的数据也不会消失。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>LocalStorage有四个方法:储存数据<code>setItem</code>，删除数据<code>removeItem</code>，取出数据<code>getItem</code>，清除数据<code>clear</code>,下面列举几个常用情况</p><h4 id="储存新数据"><a href="#储存新数据" class="headerlink" title="储存新数据"></a>储存新数据</h4><p>使用setItem来储存数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// key为你保存再localStorage中这个玩意的名字，你取名叫王大锤就在localStorage里叫王大锤</span><br><span class="line">localStorage.setItem(key,JSON.stringify(value))</span><br><span class="line">//value是你要保存的值</span><br></pre></td></tr></table></figure><p>因为localStorage仅支持存储字符类型的数据，所以先将可能为数组或对象的数据转化为JSON字符串，再进行存储。</p><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>使用getItem来获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取在localstorage里名字叫key的数据</span><br><span class="line">localStorage.getItem(key)</span><br></pre></td></tr></table></figure><p>通常要将取出的数据JSON.parse一下把他变回原来的样子，所以一般这么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(localStorage.getItem(key) || &#x27;0&#x27;)</span><br></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>其实就是修改后再存一遍，用setItem 代码我就不写了</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>使用removeItem 和取出一样 get换成remove就行 代码也不写了</p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>sessionStorage 的生命周期是仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>同localStorage 把localStorage换成sessionStorage就行</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>待施工</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap 2 双向数据绑定与服务</title>
      <link href="/2022/07/08/oBxcnSMUomsktSq3/"/>
      <url>/2022/07/08/oBxcnSMUomsktSq3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="事件和双向数据绑定"><a href="#事件和双向数据绑定" class="headerlink" title="事件和双向数据绑定"></a>事件和双向数据绑定</h2><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>Angular里提供了点击事件，写法和vue里大差不差，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button (click)=&quot;getData($event)&quot;&gt;点击触发getData函数&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>如果想要加上监听，在括号中填入$event；这个getData方法写在module里的ngOnInit后面，方法之间不用加逗号</p><h4 id="双向数据绑定步骤"><a href="#双向数据绑定步骤" class="headerlink" title="双向数据绑定步骤"></a>双向数据绑定步骤</h4><p>首先，双向数据绑定只是针对表单，想要使用双向数据绑定需要引入formsmodule，具体步骤如下</p><p>1.引入Formsmodule</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Formsmodule &#125; from &#x27;@Angular/forms&#x27;</span><br></pre></td></tr></table></figure><p>2.在想要使用双向数据绑定的地方写入ngmodel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; value=&quot;1&quot; [(ngModel)]=&quot;gender&quot; id=&quot;male&quot;&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; value=&quot;2&quot; [(ngModel)]=&quot;gender&quot; id=&quot;female&quot;&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：在select中使用双向数据绑定时写在select里</strong></p><h2 id="Angular中的服务"><a href="#Angular中的服务" class="headerlink" title="Angular中的服务"></a>Angular中的服务</h2><h4 id="什么是服务"><a href="#什么是服务" class="headerlink" title="什么是服务"></a>什么是服务</h4><p>服务是公共的方法。组件A想要使用方法a,组件B也想要使用方法a，这时方法a就可以封装进一个服务里，组件A、B只需要对服务进行引入就可以了。</p><h4 id="创建一个服务"><a href="#创建一个服务" class="headerlink" title="创建一个服务"></a>创建一个服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g service serviceName</span><br></pre></td></tr></table></figure><h4 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h4><p>在app.module里的provider里写入服务名称,同时import一下,然后再在需要使用这个服务的地方引入该服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;storageService&#125; from &#x27;./service/storage.service&#x27;</span><br></pre></td></tr></table></figure><h4 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h4><p>在需要使用的组件的module.ts文件里的构造函数中引入服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(public storage:storageService)&#123;</span><br><span class="line">    let serviceTest = this.storage.get()//get是在服务中声明的方法</span><br><span class="line">    console.log(serviceTest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap 1 常用命令与组件操作</title>
      <link href="/2022/07/07/GxVKBgUYIwmThpXh/"/>
      <url>/2022/07/07/GxVKBgUYIwmThpXh/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Angular目录分析"><a href="#Angular目录分析" class="headerlink" title="Angular目录分析"></a>Angular目录分析</h2><p>Angular是以组件为核心的框架，做的开发大多是和组件相关。而组件开发大多是在<em><strong>组件名/src/app</strong></em>里进行开发。<br>其中<strong>app-routing.module</strong>是用来配置路由,<strong>app.component.html</strong>是根组件页面,<strong>app.component.css</strong>是根组件样式表,<strong>app.module.ts</strong>是组件的根模块，告诉组件如何组装应用</p><p><em><strong>src/assets</strong></em>常用来放置一些静态的数据，例如图片等</p><p><em>src/enviornment</em>该目录下是环境的配置</p><p><em>favicon.ico</em>是项目的图标icon</p><p><em>index.html</em>是项目的入口html文件</p><p><em>style.scss</em>用来防止一些全局样式，按需写入</p><p><del>没加粗的表示没什么用</del></p><h2 id="Angular常用命令"><a href="#Angular常用命令" class="headerlink" title="Angular常用命令"></a>Angular常用命令</h2><h3 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h3><p><code>ng new xxx</code></p><h3 id="创建一个新组件"><a href="#创建一个新组件" class="headerlink" title="创建一个新组件"></a>创建一个新组件</h3><p><code>ng g c 组件名</code> or <code>ng g c 目录文件夹/组件名</code></p><p>比如我想创建一个在components文件夹下、名为news的组件，我可以这么创建<code>ng g c components/news</code></p><h3 id="挂载后运行"><a href="#挂载后运行" class="headerlink" title="挂载后运行"></a>挂载后运行</h3><p><code>ng serve --open</code></p><p>输入以上代码后访问localhost:4000可以打开你写的网页，打开速度很快，修改代码之后直接保存代码，网页也会立刻把修改的内容呈现出来，响应的很快</p><h3 id="创建一个新服务"><a href="#创建一个新服务" class="headerlink" title="创建一个新服务###"></a>创建一个新服务###</h3><p><code>ng g service serviceName</code> or <code>ng g service route/serviceName</code></p><h2 id="开始写代码吧"><a href="#开始写代码吧" class="headerlink" title="开始写代码吧"></a>开始写代码吧</h2><p><strong>Angular定义的各个组件之间可以直接调用。</strong><br>例如我新建了一个news组件，又新建了一个home组件，我可以直接在home文件夹里的html模板里调用<code>&lt;app-news&gt;&lt;/app-news&gt;</code>标签来调用news组件。</p><p><strong>Angular在定义数据的时候需要声明数据类型。</strong><br><code>public username:string = &#39;王大锤&#39;</code>                —- 字符串</p><p><code>public listName:any[]=[&#39;王大锤&#39;,&#39;李大锤&#39;,&#39;张大锤&#39;]</code> —- 数组_1</p><p><code>public arr=[&#39;1111&#39;,&#39;2222&#39;,&#39;33333&#39;];</code> —- 数组_2</p><p><code>public items:Array&lt;string&gt;=[&#39;我是第一个新闻&#39;,&#39;我是第二个新闻&#39;];</code> —- 数组_3</p><p>其中，数组有三种声明方式。推荐使用第一种。</p><p><strong>Angular在定义任何变量的时候建议都设置变量类型，甚至包括方法的形参，不设置的话可能会报错。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetData(e:any)&#123;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular不同于其他框架，声明变量时应该声明在正在使用的组件的components.ts文件中的export出的OnInit()函数里，写在constructor函数的正上方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export class NewsComponent implements OnInit &#123;</span><br><span class="line">    //变量声明在下方</span><br><span class="line">    public username:string = &#x27;王大锤&#x27;</span><br><span class="line"></span><br><span class="line">    //这是构造函数，页面刚刚准备加载时候调用，是最先调用的函数</span><br><span class="line">    constructor() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //页面初始化后调用，注意此时视图还没加载完成，无法完成dom操作</span><br><span class="line">    ngOnInit(): void &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //函数声明在这里</span><br><span class="line">  GetData(key:any)&#123;</span><br><span class="line">    return key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件操作（循环，if判断等）"><a href="#组件操作（循环，if判断等）" class="headerlink" title="组件操作（循环，if判断等）"></a>组件操作（循环，if判断等）</h2><p><strong>循环操作</strong>很简单，在加载了Angular对应插件后直接输入ngfor就可以完成 写出来是这样的</p><p><code>ngFor = &quot;let item of List;let key = index&quot;</code></p><p>其中key不是一定要声明的，List是数组名，就是我们在OnInit里定义的数组变量。</p><p><strong>条件判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngIf = &quot;true&quot;&gt;这是angular中的条件判断&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意了,Angular没有ngElse <del>至少Angular7没有</del> 所以需要否定判断的自行加!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngIf = &quot;!false&quot;&gt;这是angular中的else条件判断&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果想要让数据绑定一个变量，要用[]把数据框起来。例如写一个图片时，我们从后台拿出图片的Url数据，则需要用对img标签这么操作一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ts部分声明变量</span><br><span class="line">  public ImgUrl:any = &#x27;www.picurl.com&#x27;</span><br><span class="line"></span><br><span class="line">  //html部分</span><br><span class="line">  &lt;img [src]=&quot;ImgUrl&quot; alt=&quot;一个图片&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-07&amp;08数据库相关</title>
      <link href="/2022/06/09/ISS-07&amp;08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/06/09/ISS-07&amp;08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>##关系数据库访问控制##<br>采用贝拉模型思想，为信息和用户分别分配安全等级<br>####隐蔽信道####<br>存在某个渠道本不该用来传递信息，现在却用来传递信息，这就是隐蔽信道<br>场景：不同等级事务同步可能产生隐蔽信道，多实例有助于防止隐蔽信道<br>####关系数据库的自主访问授权####<br>使用grant和revoke发放和回收<br>否定式授权:GRANT NODELETE ON emp TO bob<br>若授权冲突，否定优先于肯定，且个体优先于小组<br>普通授权：保护数据库数据。<br>系统级授权：保护数据库模式。<br>例如创建表、删除表、增加字段、删除字段、创建用户、删除用户、建立会话、改变会话、创建触发器、执行存储过程<br>####基于视图的访问控制####<br>作用：支持基于内容的访问控制，低层数据与高层策略间的独立性<br>不足：视图多，实现和维护复杂<br>####基于角色的访问控制####<br>基本思想：给工作岗位发放访问控制授权，给用户分配工作岗位，用户享有工作岗位的授权。<br>把工作岗位抽象成角色，就是RBAC模型 角色是权限的集合 这个访问控制模型就是<strong>RBAC</strong>模型<br>####数据库的推理方法####<br>1.借助求和结果进行推理<br>2.借助记录个数进行推理<br>3.借助平均值进行推理<br>4.借助中位数进行推理<br>5.借助智能填充进行推理<br>6.借助线性特性进行推理<br>推理控制常用隐藏法：<br>结果合并式隐藏法<br>把已生成的统计查询结果按一定方式合并后再提供给查询者<br>随机抽样式隐藏法<br>从数据库中抽取一个随机样本数据集，在样本数据集上查询生成结果。<br>偏差导入式隐藏法<br>给数据库中的数据项添加随机噪声，形成加噪数据集，在加噪数据集上查询生成结果。<br>##数据库强制访问控制##<br>主要使用的OLP模型，OLP模型是基于贝拉模型的访问控制模型<br>基于标签的读：如果用户U想要访问数据D，U的等级必须完全支配D的等级，如果D包含组别和类别，U至少含D中一个组别而且有授权，并且包括D中所有类别，否则拒绝访问<br>基于标签的写：如果用户U想要访问数据D，U的等级要完全支配D的等级，并且D的等级要完全支配U的最小等级；若D含组别，则U至少包括D中任意一个组别且有写的权限，且若含类别,U要有D中所有类别的读权限；若D不含组别，且有类别，U要有D中所有类别并且有写权</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-07&amp;08数据库相关</title>
      <link href="/2022/06/09/ISS-07-08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/06/09/ISS-07-08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="关系数据库访问控制"><a href="#关系数据库访问控制" class="headerlink" title="关系数据库访问控制"></a>关系数据库访问控制</h2><p>采用贝拉模型思想，为信息和用户分别分配安全等级</p><h2 id="隐蔽信道"><a href="#隐蔽信道" class="headerlink" title="隐蔽信道"></a>隐蔽信道</h2><p>存在某个渠道本不该用来传递信息，现在却用来传递信息，这就是隐蔽信道<br>场景：不同等级事务同步可能产生隐蔽信道，多实例有助于防止隐蔽信道</p><h2 id="关系数据库的自主访问授权"><a href="#关系数据库的自主访问授权" class="headerlink" title="关系数据库的自主访问授权"></a>关系数据库的自主访问授权</h2><p>使用grant和revoke发放和回收<br>否定式授权:GRANT NODELETE ON emp TO bob<br>若授权冲突，否定优先于肯定，且个体优先于小组<br>普通授权：保护数据库数据。<br>系统级授权：保护数据库模式。<br>例如创建表、删除表、增加字段、删除字段、创建用户、删除用户、建立会话、改变会话、创建触发器、执行存储过程</p><h2 id="基于视图的访问控制"><a href="#基于视图的访问控制" class="headerlink" title="基于视图的访问控制"></a>基于视图的访问控制</h2><p>作用：支持基于内容的访问控制，低层数据与高层策略间的独立性<br>不足：视图多，实现和维护复杂</p><h2 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h2><p>基本思想：给工作岗位发放访问控制授权，给用户分配工作岗位，用户享有工作岗位的授权。<br>把工作岗位抽象成角色，就是RBAC模型 角色是权限的集合 这个访问控制模型就是<strong>RBAC</strong>模型</p><h2 id="数据库的推理方法"><a href="#数据库的推理方法" class="headerlink" title="数据库的推理方法"></a>数据库的推理方法</h2><p>1.借助求和结果进行推理<br>2.借助记录个数进行推理<br>3.借助平均值进行推理<br>4.借助中位数进行推理<br>5.借助智能填充进行推理<br>6.借助线性特性进行推理<br>推理控制常用隐藏法：<br>结果合并式隐藏法<br>把已生成的统计查询结果按一定方式合并后再提供给查询者<br>随机抽样式隐藏法<br>从数据库中抽取一个随机样本数据集，在样本数据集上查询生成结果。<br>偏差导入式隐藏法<br>给数据库中的数据项添加随机噪声，形成加噪数据集，在加噪数据集上查询生成结果。</p><h2 id="数据库强制访问控制"><a href="#数据库强制访问控制" class="headerlink" title="数据库强制访问控制"></a>数据库强制访问控制</h2><p>主要使用的OLP模型，OLP模型是基于贝拉模型的访问控制模型<br>基于标签的读：如果用户U想要访问数据D，U的等级必须完全支配D的等级，如果D包含组别和类别，U至少含D中一个组别而且有授权，并且包括D中所有类别，否则拒绝访问<br>基于标签的写：如果用户U想要访问数据D，U的等级要完全支配D的等级，并且D的等级要完全支配U的最小等级；若D含组别，则U至少包括D中任意一个组别且有写的权限，且若含类别,U要有D中所有类别的读权限；若D不含组别，且有类别，U要有D中所有类别并且有写权</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-05&amp;&amp;06操作系统安全机制</title>
      <link href="/2022/06/09/ISS%2005&amp;&amp;06%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/06/09/ISS%2005&amp;&amp;06%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="用户划分的三分法与文件权限"><a href="#用户划分的三分法与文件权限" class="headerlink" title="用户划分的三分法与文件权限"></a>用户划分的三分法与文件权限</h2><p>属主：文件的拥有者。 属组：属主的首选用户组。 其余：除属主和属组之外的用户全体<br>属主域中只能有属主一个用户，其他两个的用户域都可以有多个用户。<br>例题：设在某UNIX操作系统中，部分用户组的配置信息如下：<br>    grp1:x:300:usr1,usr2,usr3,usr4<br>    grp2:x:301:usr5,usr6,usr7,usr8,usr9<br>系统中部分文件的权限配置信息如下：<br>    rw-r-x–x    usr1    grp1    …… File1<br>    r—w—x    usr5    grp2    …… File2<br>请问，用户usr1、usr2和usr5可以对文件file1执行什么操作？用户usr6可以对文件file2执行什么操作？<br>可对file1的操作：<br>usr1—属主—读和写；usr2—属组—读和执行；usr5—其余—执行。<br>可对file2的操作：usr6—属组—写。</p><blockquote><p>如果文件是自主访问控制，文件的属主可以修改文件的权限。换句话说，文件的属主可以对文件有任何权限。</p></blockquote><h2 id="和权限相关的进程问题"><a href="#和权限相关的进程问题" class="headerlink" title="和权限相关的进程问题"></a>和权限相关的进程问题</h2><p>如果执行程序权限有s，代表着进程变身，执行程序的时候会变为该权限对应的用户域<br>tips：excute是跳转执行，不会执行excute之后的语句</p><h2 id="访问控制中的特权"><a href="#访问控制中的特权" class="headerlink" title="访问控制中的特权"></a>访问控制中的特权</h2><p>在某种程度上，拥有特权可免受常规访问控制的约束。<br>特权是双刃剑：系统服务之所需，安全威胁之所在。<br>特权分离原则：财务权–出纳权+会计权<br>最小特权原则：杀鸡不要配牛刀<br>特权分离是实现最小特权原则的基础。<br>##文件加密##<br>为什么要加密？<br>文件离开操作系统的控制范围也不泄漏内容。<br>文件加密方法：<br>单个文件加密<br>整个磁盘加密<br>文件系统加密（目录树加密）</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-03系统安全基础&amp;04用户身份认证技术</title>
      <link href="/2022/06/08/ISS-03%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80&amp;04%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/06/08/ISS-03%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80&amp;04%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="纯软件的不足"><a href="#纯软件的不足" class="headerlink" title="纯软件的不足"></a>纯软件的不足</h2><p>可能会遭受程序的篡改和数据的泄露，安全会发成动摇 </p><h2 id="可信和信任"><a href="#可信和信任" class="headerlink" title="可信和信任"></a>可信和信任</h2><p>可信构造块：CPU RAM 控制器中的引导ROM 可插拔设备<br>可信平台模块TPM</p><h2 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h2><p>基于口令的身份认证:静态口令，动态口令<br>质询-响应式身份认证：质询问题生成 社交网络，隐私，专业知识&amp;&amp;响应：问题回答<br>基于生物特征的身份认证：指纹认证，人脸识别，虹膜识别<br>基于位置的身份认证</p><h2 id="口令处理方法"><a href="#口令处理方法" class="headerlink" title="口令处理方法"></a>口令处理方法</h2><p>增强口令字段生成：<br>1.用一个64位全0字符串的二进制位串构造成一个数据块Dp<br>2.K=用户的口令，i=0<br>3.Dc=Acrypt（K,Dp）<br>4.Dp=Dc,i=i+1<br>5.如果i小于25，回到第三步<br>6.S=Atrans(Dc)，取s 作为口令字段信息</p><p>撒盐算法：<br>1.把盐值附加在口令上：Dmp = Dpw || Dsalt<br>2.对生成的Dtmp进行哈希加密<br>3.Dhash作为返回结果</p><p>撒盐身份认证：口令字段生成–Agen（Dsalt，Dpw）<br>1.给口令使用撒盐算法，结果作为密钥K<br>2.和增强口令字段生成一样的过程 其中的K换成了撒盐算法生成的K</p><p>撒盐身份认证：口令字段维护<br>1.接受用户给的口令Dpw<br>2.生成一个盐值：Dsalt = Arandom（）<br>3.生成口令信息：S = Agen（Dsalt，Dpw）<br>4.将Dsalt和S存入数据库的口令字段中</p><h2 id="网络环境用户身份认证"><a href="#网络环境用户身份认证" class="headerlink" title="网络环境用户身份认证"></a>网络环境用户身份认证</h2><p>1.方案4.7<br>用户的期望：无论操控哪台计算机，只要以相同的身份登录，都能获得所需的服务<br>用户提供：账户信息+口令信息和身份认证请求，把请求发送给服务器后由服务器做身份认证<br>服务器做的：根据用户提供的账户信息和口令信息，结合身份认证信息数据库中的对应信息，判断账户和口令的合法性，再把结果返回给客户机<br>2.方案4.8<br>客户机和服务机都可以执行认证，根据用户确定哪些是由客户机执行，哪些是由服务器执行</p><p>密码体制：单钥密码体制和双钥密码体制，单是同一个密钥既加密也解密，双钥密码体制是公钥加密，私钥解密<br>数字签名是私钥签名，公钥验证，注意区别</p><p>互认证的加密机制<br>A给B发消息，用B的公钥加密会话密钥，然后再用A的私钥加密之前的加密结果 这样反过来解密的时候双方都可以很容易的获取到会话密钥</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-01绪论&amp;02经典模型</title>
      <link href="/2022/06/08/ISS-01%E7%BB%AA%E8%AE%BA&amp;02%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/06/08/ISS-01%E7%BB%AA%E8%AE%BA&amp;02%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="信息安全经典要素"><a href="#信息安全经典要素" class="headerlink" title="信息安全经典要素"></a>信息安全经典要素</h2><span id="more"></span><p>  机密性confidentiality</p><blockquote><p>机密性是指防止私密的或机密的信息泄露给非授权的实体的属性</p></blockquote><p>  完整性 Integrity</p><blockquote><p>完整性分为数据完整性和系统完整性，数据完整性指确保数据（包括软件代码）只能按照授权的指定方式进行修改的属性，系统完整性指系统没有受到未经授权的操控进而完好无损的执行预定功能的属性。</p></blockquote><p> 可用性 availability</p><blockquote><p>可用性是指确保系统及时工作并向授权用户提供所需服务的属性</p></blockquote><h2 id="安全策略和安全模型"><a href="#安全策略和安全模型" class="headerlink" title="安全策略和安全模型"></a>安全策略和安全模型</h2><p>安全策略：安全策略是指关于允许什么和禁止什么的规定。（安全策略是给人看的）<br>安全模型：安全模型是指用更加形式化的或数学化的术语对安全策略的重新表述。（安全模型是给计算机看的）</p><h2 id="DAC-自主访问控制"><a href="#DAC-自主访问控制" class="headerlink" title="DAC 自主访问控制"></a>DAC 自主访问控制</h2><p>允许某个主体显式地指定其他主体对该主体所拥有的信息资源是否可以访问以及可执行的访问类型。例如iphone手机的权限管理就是DAC自主访问控制。</p><h2 id="MAC-强制访问控制"><a href="#MAC-强制访问控制" class="headerlink" title="MAC 强制访问控制"></a>MAC 强制访问控制</h2><p>根据客体中信息的敏感标记和访问敏感信息的主体的访问级对客体访问实行限制。<br>我的定义：如果一个系统中只有系统才能对客体进行访问控制，用户自己不能改变这种控制，这就是强制访问控制。<br>换成安全策略和安全策略管理员同理。</p><h2 id="贝拉模型"><a href="#贝拉模型" class="headerlink" title="贝拉模型"></a>贝拉模型</h2><p>构成：简单安全特性（ss-特性）,星号安全特性（*-特性）,自主安全特性(ds-特性)和一个基本安全定理<br>以下中，f表示安全级别,&gt;=表示支配关系,f-c表示当前安全级别<br>简单安全特性：f(sub)&gt;=f(Obj)</p><p>星号安全特性:<br>1.若acc是r,则f-c(Sub)&gt;=f(obj)<br>2.若acc是a,则f(obj)&gt;=f-c(Sub)<br>3.若acc是w,则f(obj)=f-c(Sub)</p><p>自主安全特性：<br>acc一定在访问控制矩阵M中</p><p>基本安全定理：<br>如果系统每次变化都满足上述三个特性的要求，则系统的安全性一定不会被破坏</p><h2 id="毕巴模型"><a href="#毕巴模型" class="headerlink" title="毕巴模型"></a>毕巴模型</h2><p>毕巴模型是完整性访问模型，也是强制访问模型<br>绝对支配：&gt; 支配:&gt;=<br>写规则：主体S支配客体O<br>执行规则：主体S1支配主体S2<br>低水标模型读规则：imin = min(i(S),i(O))，那么，不管完整性级别如何，S都可以读O，但是，“读”操作实施后，主体S的完整性级别被调整为imin。<br>环模型读规则：不管完整性级别如何，任何主体都可以读任何客体。</p><h2 id="TE模型和DTE模型"><a href="#TE模型和DTE模型" class="headerlink" title="TE模型和DTE模型"></a>TE模型和DTE模型</h2><p>TE模型不足：<br>访问控制权限的配置比较复杂<br>二维表结构无法反映系统的内在关系<br>控制策略的定义需要从零开始<br>DTE模型特点：<br>使用高级语言描述访问控制策略<br>采用隐含方式表示文件安全属性<br>功能：类型描述 类型赋值 域描述 初始域设定 </p><h2 id="默克尔树模型"><a href="#默克尔树模型" class="headerlink" title="默克尔树模型"></a>默克尔树模型</h2><p>摆烂 就记住公式：f(i,i,D) = h(Di) f(i,j,D) = h(f(i,(i+j-1)/2,D) || f((i+j+1)/2,j,D)</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANTD的选择框下拉绑定和查询问题</title>
      <link href="/2022/04/17/%E5%85%B3%E4%BA%8Eantd%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E6%A1%86%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E6%88%90%E5%8A%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/17/%E5%85%B3%E4%BA%8Eantd%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E6%A1%86%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E6%88%90%E5%8A%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>在使用a-select的时候发现下拉框的内容在绑定的v-model是item.id时使用搜索框自带的show-search的搜索功能会导致搜索出来的字段是id，而不是根据a-selection里的item.name字段正常显示：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-select</span></span></span><br><span class="line"><span class="tag"><span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span></span></span><br><span class="line"><span class="tag">@<span class="attr">change</span>=<span class="string">&quot;Onchange&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">show-search</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-decorator</span>=<span class="string">&quot;[&#x27;State&#x27;]&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a-selection</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-for</span>=<span class="string">&quot;(item,index) in List&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">&#123;item.name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-selection</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><blockquote><p>使用：filter-option配置：</p></blockquote><p>在select里添加filter-option字段，并且在script文件里做出如下方法声明</p><p>Html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-select</span></span></span><br><span class="line"><span class="tag"><span class="attr">:filterOption</span>=<span class="string">&quot;filterOption&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span></span></span><br><span class="line"><span class="tag">@<span class="attr">change</span>=<span class="string">&quot;Onchange&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">show-search</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-decorator</span>=<span class="string">&quot;[&#x27;State&#x27;]&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a-selection</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-for</span>=<span class="string">&quot;(item,index) in List&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">&#123;item.name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-selection</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 将输入的内容与显示的内容进行匹配</span></span><br><span class="line">    filterOption (value, option) &#123;</span><br><span class="line">      <span class="keyword">return</span> option.<span class="property">componentOptions</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">text</span>.<span class="title function_">indexOf</span>(value) &gt;= <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>成功解决</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> antdv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
