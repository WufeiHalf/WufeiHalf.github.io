<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vuex的路由</title>
      <link href="/2023/03/22/ZEXqyWdiiXwqjEjK/"/>
      <url>/2023/03/22/ZEXqyWdiiXwqjEjK/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>路由：用我的话说，路由就是访问某一个页面，可以在不发生页面跳转的前提下完成不同组件的挂载与销毁。<br>为什么要使用路由？因为使用路由开发出来的页面维护而且一目了然啊，这还用问？路由只应用在SPA（单页面应用）里</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装vuerouter"><a href="#安装vuerouter" class="headerlink" title="安装vuerouter"></a>安装vuerouter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router@3</span><br></pre></td></tr></table></figure><h3 id="在main-js里导入并配置vueRouter"><a href="#在main-js里导入并配置vueRouter" class="headerlink" title="在main.js里导入并配置vueRouter"></a>在main.js里导入并配置vueRouter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  router:router</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="新建一个router文件夹，在文件夹里创建一个index-js文件，用来配置路由信息"><a href="#新建一个router文件夹，在文件夹里创建一个index-js文件，用来配置路由信息" class="headerlink" title="新建一个router文件夹，在文件夹里创建一个index.js文件，用来配置路由信息"></a>新建一个router文件夹，在文件夹里创建一个index.js文件，用来配置路由信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line">//导入需要的组件</span><br><span class="line">import About from &#x27;../pages/About&#x27;</span><br><span class="line">import Home from &#x27;../pages/Home&#x27;</span><br><span class="line">//创建并暴露一个路由器</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:&#x27;/about&#x27;,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:&#x27;/home&#x27;,</span><br><span class="line">            component:Home</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="新建一个pages文件夹，将需要通过路由导航到的组件放到里面"><a href="#新建一个pages文件夹，将需要通过路由导航到的组件放到里面" class="headerlink" title="新建一个pages文件夹，将需要通过路由导航到的组件放到里面"></a>新建一个pages文件夹，将需要通过路由导航到的组件放到里面</h3><p>这就不写代码了吧 没得写啊</p><h3 id="在需要发生路由跳转的地方（a标签）里，将a标签修改为router-link"><a href="#在需要发生路由跳转的地方（a标签）里，将a标签修改为router-link" class="headerlink" title="在需要发生路由跳转的地方（a标签）里，将a标签修改为router-link"></a>在需要发生路由跳转的地方（a标签）里，将a标签修改为router-link</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;list-group-item active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>介绍一下其中的属性：<br>1.active-class：当路由被激活的时候调用的样式<br>2.to：在index.js里配置的路由的路径（path）</p><h3 id="在需要切换路径显示路由的地方写router-view"><a href="#在需要切换路径显示路由的地方写router-view" class="headerlink" title="在需要切换路径显示路由的地方写router-view"></a>在需要切换路径显示路由的地方写router-view</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.被路由访问的文件并不需要在App.vue或者是父组件里进行引入，因为不是直接对其操作，是通过路由进行操作的。<br>2.通过路由切换的组件，被切换的组件是被销毁，替换过去的组件是被挂载，并非简单的display：none<br>3.每个组件都有自己的$route，存储着自己的路由信息；但是只有一个$router。<br>4.路由组件放在pages文件夹，一般组件放在components文件夹。</p><h2 id="嵌套路由（多级路由）"><a href="#嵌套路由（多级路由）" class="headerlink" title="嵌套路由（多级路由）"></a>嵌套路由（多级路由）</h2><p>如果想在路由中继续使用路由，即给一级路由页面配置二级路由乃至更多，应该使用children属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//router/index.js</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:&#x27;/about&#x27;,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:&#x27;/home&#x27;,</span><br><span class="line">            component:Home,</span><br><span class="line">            children:[</span><br><span class="line">                &#123;</span><br><span class="line">                    path:&#x27;news&#x27;,</span><br><span class="line">                    component:News</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path:&#x27;message&#x27;,</span><br><span class="line">                    component:Message</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在使用的时候，routerlink标签里使用to的时候应该写完整的路径，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;list-group-item active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="路由跳转时传参"><a href="#路由跳转时传参" class="headerlink" title="路由跳转时传参"></a>路由跳转时传参</h2><h3 id="使用query传参"><a href="#使用query传参" class="headerlink" title="使用query传参"></a>使用query传参</h3><p>传递者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//跳转路由并携带query，to的字符串写法</span><br><span class="line">&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;item.id&#125;&amp;title=$&#123;item.title&#125;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">//跳转路由并携带query，to的对象写法</span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">    path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">        id:item.id,</span><br><span class="line">        title:item.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>接受者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$route.query.id</span><br><span class="line">this.$route.query.title</span><br></pre></td></tr></table></figure><h3 id="使用params传参"><a href="#使用params传参" class="headerlink" title="使用params传参"></a>使用params传参</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//跳转路由并携带params，to的字符串写法</span><br><span class="line">&lt;router-link :to=&quot;`/home/message/detail/$&#123;item.id&#125;/$&#123;item.title&#125;`&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">//跳转路由并携带params，to的对象写法</span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">    path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">    params:&#123;</span><br><span class="line">        id:item.id,</span><br><span class="line">        title:item.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这么写，需要在router文件里对detail进行配置，告诉router说detail后面的参数第一个是id，第二个是title</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path:&#x27;detail/:id/:title&#x27;</span><br></pre></td></tr></table></figure><p>接受者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$route.params.id</span><br><span class="line">this.$route.params.title</span><br></pre></td></tr></table></figure><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>在路由过长的时候使用对象写法的to，可以用来简化路由配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//index.js里加一个name配置项</span><br><span class="line">//在routerlink标签里把path修改为：</span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">    name:&#x27;detail&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">        id:item.id,</span><br><span class="line">        title:item.title</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&quot;&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>使用params路由传参不可以使用命名路由</p><h2 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h2><p>在router里配置一个props属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//布尔值写法</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;detail/:id/:title&#x27;,</span><br><span class="line">    component:Detail,</span><br><span class="line">    props:true</span><br><span class="line">&#125;</span><br><span class="line">//函数写法</span><br><span class="line">&#123;</span><br><span class="line">    path:&#x27;detail/:id/:title&#x27;,</span><br><span class="line">    component:Detail,</span><br><span class="line">    props($route)&#123;</span><br><span class="line">        return &#123;id:$route.query.id,title:$route.query.title&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;id&#125;&#125;</span><br><span class="line">&#123;&#123;title&#125;&#125;</span><br><span class="line">props:[id,title]</span><br></pre></td></tr></table></figure><h2 id="router-link-的replace标签"><a href="#router-link-的replace标签" class="headerlink" title="router-link 的replace标签"></a>router-link 的replace标签</h2><p>原本的历史记录访问是栈，使用了replace后，当前页面跳转的时候，当前页面出栈+新页面入栈，点不了返回咯</p><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>如果想实现路由导航又不能使用router-link，想使用函数进行路由跳转，就需要编程式路由导航</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;pushShow(item)&quot;&gt;push查看&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">pushShow(item)&#123;</span><br><span class="line">                // console.log(&#x27;push查看&#x27;,this.$router)</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">    name:&#x27;detail&#x27;,</span><br><span class="line">    params:&#123;</span><br><span class="line">        id:item.id,</span><br><span class="line">        title:item.title</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>这里的跳转有好几个api，分别介绍一下：<br>1.push：和浏览器普通访问一样<br>2.replace：同router-link的replace标签<br>3.back：后退<br>4.forward：前进<br>5.go：函数里是数字，正数代表点x下前进，负数代表点x下后退</p><h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><p>跳转路由的时候，之前的页面会被销毁。如果不想让页面被销毁，可以使用keep-alive标签让路由不销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>include里是组件名，组件里写的那个name</p><p>如果爱想要缓存指定的组件，得这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h2 id="路由组件独有的生命周期钩子"><a href="#路由组件独有的生命周期钩子" class="headerlink" title="路由组件独有的生命周期钩子"></a>路由组件独有的生命周期钩子</h2><p>activated():激活<br>deactivated()：不激活</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vuex的store</title>
      <link href="/2023/03/20/X8Emw3N5i1Dg3r7h/"/>
      <url>/2023/03/20/X8Emw3N5i1Dg3r7h/</url>
      
        <content type="html"><![CDATA[<h2 id="vuex-简介"><a href="#vuex-简介" class="headerlink" title="vuex 简介"></a>vuex 简介</h2><p>先说概念：<br>在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写）,也是一种组件间的通信方式，且适用于任何组件间的通信。z<br>当我们想要多组件共享数据的时候，之前是通过使用全局事件总线来实现这个功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//传值者使用</span><br><span class="line">$bus.$emit(&#x27;getX&#x27;,x)</span><br><span class="line"></span><br><span class="line">//调用者使用</span><br><span class="line">$bus.$on(&#x27;getX&#x27;,回调)</span><br></pre></td></tr></table></figure><p>如果想要对x不仅仅是调用，还要对x修改，并且很多组件都要调用和修改这个x的话，那么全局事件总线会显得过于繁琐。<br>vuex的出现就是解决这个问题的。<br>使用vuex存储x，那么全局所有组件都可以使用或修改x。  </p><h3 id="使用vuex的场景"><a href="#使用vuex的场景" class="headerlink" title="使用vuex的场景"></a>使用vuex的场景</h3><p>1.多个组件都依赖同一个状态<br>2.来自不同组件的行为需要变更同一状态。</p><h2 id="vuex的工作原理"><a href="#vuex的工作原理" class="headerlink" title="vuex的工作原理"></a>vuex的工作原理</h2><p>vuex分为三个部分：Actions，Mutations,states，这三个部分由store管理。</p><p>states:本质是一个object 对象，里面存储着很多keyvalue。</p><p>在组件里使用dispatch的Api，有两个参数<br>1.动作类型（字符串）<br>2.动作的值</p><p>在调用dispatch之后，会发给Actions板块。<br>Actions板块也是一个object对象，而且里面一定会有一个值（函数）和你dispatch调用的一样，Action就会调用这个函数。<br>同时，在调用的函数里，人工调用commit函数，commit函数的参数和dispatch一样。提交后，工作流程走到Mutation里。<br>Mutation也是一个object，里面也有会一个对应的函数，函数调用的时候会调用两个人，一个是state，一个是你动作的值。底层自动会完成Mutate操作，然后修改state里对应的值。在此之后，vuex会帮你重新渲染组件。</p><h3 id="为什么需要有Action这一板块"><a href="#为什么需要有Action这一板块" class="headerlink" title="为什么需要有Action这一板块"></a>为什么需要有Action这一板块</h3><p>如果当你进行的动作需要进行ajax请求，那么只能在action板块里发送请求。如果不需要通过Actions，可以在组件里直接调用commit，直接完成操作。</p><h2 id="搭建Vuex"><a href="#搭建Vuex" class="headerlink" title="搭建Vuex"></a>搭建Vuex</h2><p>1.npm i vuex</p><p>2.Vue.use(Vuex)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在main.js里使用vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>3.store<br>在New Vue里面新建一个store<br><code>store:&#39;ABC&#39;</code><br>接下来是创建store，有两种方法<br>1.新建一个vuex文件夹，里面放置store.js文件</p><p>2.新建一个store文件夹，里面放置index.js文件（官方文档版）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const state = &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后再main.js里引入store<br><code>import store from &#39;路径&#39;</code></p><p>注意：use(vuex)需要在创建store实例之前。<br>原因：脚手架的import的问题 因为脚手架会提前执行import。 所以在store.js里使用Vue.use(Vuex)</p><p>注意第二点：有业务逻辑或者是ajax请求，全部放在action里面！</p><p>注意第三点：不需要actions时可以直接调用commit</p><h2 id="store里的其他配置项"><a href="#store里的其他配置项" class="headerlink" title="store里的其他配置项"></a>store里的其他配置项</h2><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>getters:对state里的数据进行加工，需要用return显示出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters = &#123;</span><br><span class="line">    bigSum(state)&#123;</span><br><span class="line">        return state.num*10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MapState"><a href="#MapState" class="headerlink" title="MapState"></a>MapState</h3><p>mapState：映射状态，将state里的数据映射出来，可以放在computed里面直接使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//借助mapState生成计算属性，从state中读取数据（对象写法）</span><br><span class="line">...mapState(&#123;school:&#x27;school&#x27;，subject:&#x27;subject&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">//数组写法</span><br><span class="line">...mapState([&#x27;school&#x27;,&#x27;subject&#x27;])</span><br></pre></td></tr></table></figure><p>完成这一步需要在对应的组件里引入mapState from vuex</p><h3 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h3><p>映射getter里的数据，用法和上面的类似。</p><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><p>代替直接进行的 dispatch 操作<br>但是传值的value是一个鼠标点击事件。所以点击的时候应该传入你需要传入的值。<br>也有对象和数组的写法，和上面的写法类似。</p><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>代替直接进行的 commit 操作<br>但是传值的value是一个鼠标点击事件。所以点击的时候应该传入你需要传入的值。<br>也有对象和数组的写法，和上面的写法类似。</p><h2 id="模块化-namespace"><a href="#模块化-namespace" class="headerlink" title="模块化 namespace"></a>模块化 namespace</h2><p>当项目过于庞大的时候，可能需要在vuex里配置过多的数据，如果全部放在state里会显得数据过于臃肿，也不方便后期维护，git上也容易产生冲突。<br>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const countOptions = &#123;</span><br><span class="line">    namespaced:true,</span><br><span class="line">    actions:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    state:&#123;</span><br><span class="line">        sum:0,</span><br><span class="line">        bigSum:0</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">const personOptions = &#123;</span><br><span class="line">    namespaced:true,</span><br><span class="line">    actions:&#123;&#125;,</span><br><span class="line">    mutations:&#123;&#125;,</span><br><span class="line">    state:&#123;</span><br><span class="line">        personList:[&#123;</span><br><span class="line">            id:&#x27;001&#x27;,</span><br><span class="line">            name:&#x27;张三&#x27;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:countOptions,</span><br><span class="line">        b:personOptions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>这样修改之后，在使用mapState等功能的时候需要按照如下进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...mapState([&#x27;a&#x27;,&#x27;b&#x27;])</span><br><span class="line">//调用时</span><br><span class="line">&#123;&#123;a.sum&#125;&#125;</span><br><span class="line"></span><br><span class="line">//或者这样写（需要namespaced）</span><br><span class="line">...mapState(&#x27;a&#x27;,[&#x27;sum&#x27;,&#x27;num&#x27;])</span><br><span class="line"></span><br><span class="line">//手写计算属性的时候</span><br><span class="line">return this.$store.state.a.sum</span><br><span class="line"></span><br><span class="line">//需要commit的时候</span><br><span class="line"> this.$store.commit(&#x27;b/ ADD_PERSON&#x27;,param)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue的插槽</title>
      <link href="/2023/03/17/BZPCtneLVd8ppO98/"/>
      <url>/2023/03/17/BZPCtneLVd8ppO98/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><p>插槽的作用：<br>想要让父组件向子组件的指定位置插入Html结构，也是父子组件通讯的一种<br>对于一个组件，如果想复用，同时又要满足不同的需求，例如如下场景：<br>需要三个列表单组件 每个组件里面除了内容不同，其他要求都大致相同。组件1里需要有图片，组件2里需要有视频，组件3里需要有列表，可以使用插槽来解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//App.Vue</span><br><span class="line">&lt;category&gt;</span><br><span class="line">&lt;img src=&quot;&quot;&gt;</span><br><span class="line">&lt;/category&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//category.Vue</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot&gt;如果App.vue里category中间没东西，就会显示这行字，否则不显示这行字，显示中间的dom元素&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p> 如果说还需要增加一个插槽，实现一一对应的结果，可以进行如下操作：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//App.Vue</span><br><span class="line">&lt;category&gt;</span><br><span class="line">&lt;img slot=&quot;center&quot; src=&quot;&quot;&gt;</span><br><span class="line">&lt;img slot=&quot;bottom&quot; src=&quot;&quot;&gt;</span><br><span class="line">&lt;/category&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//category.Vue</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot name=&quot;center&quot;&gt;如果App.vue里category中间没东西，就会显示这行字，否则不显示，显示中间的dom元素</span><br><span class="line">&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;bottom&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>name是center的img会被加载后放在了上面，name是bottom的img会被加载放在下面</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>数据在组件本身，但是根据数据生成的结构由父组件（即调用者决定）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//App.Vue</span><br><span class="line">&lt;category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;(item,index) in scopeData.names&quot; :keys=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/category&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//category.Vue</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot :names=&quot;names&quot;&gt;如果App.vue里category中间没东西，就会显示这行字，否则不显示，显示中间的dom元素</span><br><span class="line">&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//names是category里的数据</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nextick的用法</title>
      <link href="/2023/03/07/OEda78EeU38BCoD3/"/>
      <url>/2023/03/07/OEda78EeU38BCoD3/</url>
      
        <content type="html"><![CDATA[<h2 id="nextick"><a href="#nextick" class="headerlink" title="nextick"></a>nextick</h2><p>nextick所指定的回调会在dom节点更新后完成</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue中的代理配置</title>
      <link href="/2023/03/07/GBF6sW1rA61qrO8V/"/>
      <url>/2023/03/07/GBF6sW1rA61qrO8V/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>1.cors:后端同学来解决</p><p>2.jsonp:需要前端和后端人员一起来处理，有点麻烦</p><p>3.代理服务器 方式1：<br>proxy:vue向服务器请求数据的时候，从向服务器请求改为向代理服务器请求数据，代理服务器的端口也是8080，这样vue在发送请求的时候就不是跨域发送请求了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vue-config.js</span><br><span class="line">devServer: &#123;    </span><br><span class="line">    proxy: &#x27;服务器地址&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vue组件里</span><br><span class="line">axios.get(&#x27;localhost:8080/student&#x27;)</span><br></pre></td></tr></table></figure><p>好像也不太好？<br>缺点：1.不能配置多个代理<br>2.如果public根目录下有同名文件 会先找public下的（开发中才会这样）</p><p>4.代理服务器 方式2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// vue-config.js</span><br><span class="line">devServer: &#123;    </span><br><span class="line">    proxy: &#123;</span><br><span class="line">        &#x27;/api&#x27;:&#123;</span><br><span class="line">            target:&#x27;&lt;url&gt;&#x27;,</span><br><span class="line">            pathRewrite:&#123;:&#x27;^/api&#x27;:&#x27;&#x27;&#125;</span><br><span class="line">            ws:true,</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;/foo&#x27;:&#123;</span><br><span class="line">            target:&#x27;&lt;otherUrl&gt;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vue组件里</span><br><span class="line">axios.get(&#x27;localhost:8080/student&#x27;)</span><br></pre></td></tr></table></figure><p>如果想要使用代理服务器，走的是api里的url，但是在访问的时候需要加上/api的前缀，写在端口号之后</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue中组件通讯(自定义事件和全局事件总线)</title>
      <link href="/2023/03/04/wWicEMeIsFCgzmqu/"/>
      <url>/2023/03/04/wWicEMeIsFCgzmqu/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="子组件给父组件传值"><a href="#子组件给父组件传值" class="headerlink" title="子组件给父组件传值"></a>子组件给父组件传值</h2><p>除了上篇提到的方法，还可以使用自定义事件的方法实现子组件和父组件的数据交互。<br>在父组件里使用子组件的时候绑定一个v-on 例如下图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;student v-on:sendMessage=&quot;demo&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo()&#123;</span><br><span class="line">    console.log(&#x27;demo被调用了&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// student.vue</span><br><span class="line">&lt;button :click=&quot;sendStudentName&quot;&gt;点击&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendStudentName()&#123;</span><br><span class="line">    this.$emit(&#x27;sendMessage&#x27;)</span><br><span class="line">    //打印出了上面的console.log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用，不需要声明props<br>如果想传值，在emit里逗号隔开</p><p>还可以使用ref来代替v-on</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;student ref=&quot;student&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo()&#123;</span><br><span class="line">    console.log(&#x27;demo被调用了&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">mounted()&#123;</span><br><span class="line">    this.$ref.student.$on(&#x27;sendMessage&#x27;,this.demo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// student.vue</span><br><span class="line">&lt;button :click=&quot;sendStudentName&quot;&gt;点击&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sendStudentName()&#123;</span><br><span class="line">    this.$emit(&#x27;sendMessage&#x27;)</span><br><span class="line">    //打印出了上面的console.log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定后的解绑"><a href="#绑定后的解绑" class="headerlink" title="绑定后的解绑"></a>绑定后的解绑</h2><p>在被调用的子组件里使用<code>this.$off(&#39;eventName&#39;)</code>解绑对应事件<br>解绑多个事件 可以把多个事件放进数组里，一起解绑<br><code>this.$off()</code> 全部解绑</p><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>前面说的方法实现同级组件之间传值都太过繁琐，可以使用全局事件总线来达成这个目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">New Vue  (&#123;</span><br><span class="line">    el:&#x27;#app&#x27;,</span><br><span class="line">    render: h=&gt;h(app),</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">        this.prototype.bus = this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>举个例子，比如说Student组件想要给School组件传值</p><p>```<br>//student组件里<br>sendMessage(){<br>    this.$bus.$emit(‘demo’,123123)<br>}</p><p>//school组件里<br>mounted(){<br>    this.$bus.$on(‘demo’,(data)=&gt;{<br>        console.log(data)<br>    })<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue的props，mixin和插件</title>
      <link href="/2023/03/03/H8GOknb5eAWff1Js/"/>
      <url>/2023/03/03/H8GOknb5eAWff1Js/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>举一个实际情况的例子，APP.vue在调用你写的Hello.vue的时候，如果想要传入自己的值，有以下几种方法，体现组件是复用，但是数据是动态的</p><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//app.vue里</span><br><span class="line">&lt;hello name=&quot;AA&quot; sex=&quot;BB&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Hello.vue里</span><br><span class="line">export default&#123;</span><br><span class="line">    name:&#x27;&#x27;hello&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg:&#x27;123&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:[&#x27;name&#x27;,&#x27;sex&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想传的值是数字，可以给传的属性前面加冒号 例如 :age</p><p>第二种（声明数据类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//app.vue里</span><br><span class="line">&lt;hello name=&quot;AA&quot; sex=&quot;BB&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Hello.vue里</span><br><span class="line">export default&#123;</span><br><span class="line">    name:&#x27;&#x27;hello&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg:&#x27;123&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        age:Number,</span><br><span class="line">        name:String,</span><br><span class="line">        sex:String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了数据类型，虽然区别不大，但是报错很明确</p><p>第三种（数据类型限制+默认值+是否必要限制）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//app.vue里</span><br><span class="line">&lt;hello name=&quot;AA&quot; sex=&quot;BB&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Hello.vue里</span><br><span class="line">export default&#123;</span><br><span class="line">    name:&#x27;&#x27;hello&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg:&#x27;123&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        name:&#123;</span><br><span class="line">            type:String,</span><br><span class="line">            required:true</span><br><span class="line">        &#125;,</span><br><span class="line">        age:&#123;</span><br><span class="line">            type:Number,</span><br><span class="line">            default:99 //默认值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好看懂，不多做解释了<br>props优先级比data里的数据高，并且最好不要对props传来的数据进行修改，非要修改的话可以在data里声明一个替身，然后对其进行修改</p><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h2><p>作用就是两个组件使用同一个函数<br>创建一个mixin.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// mixin.js</span><br><span class="line">export const mixinName = &#123;</span><br><span class="line">    method:&#123;</span><br><span class="line">        showName()&#123;</span><br><span class="line">            alert(this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用showName的函数的组件里先import这个mixin.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mixinName&#125; from &#x27;../mixin.js&#x27;</span><br><span class="line">mixin:[mixinName]</span><br></pre></td></tr></table></figure><p>mixin的优先级低于data里的数据</p><p>如果想要所有的VC和VM 全局都使用这个mixin的话，直接在main.js里进行注册声明就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">import &#123;mixinName1,mixinName2&#125; from &#x27;../mixin&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.mixin(mixinName1)</span><br><span class="line">Vue.mixin(mixinName2)</span><br></pre></td></tr></table></figure><h2 id="插件plugins"><a href="#插件plugins" class="headerlink" title="插件plugins"></a>插件plugins</h2><p>首先新建一个plugin.js文件<br>在main.js里应用vue.use(plugins)<br>可以在插件里声明全局过滤器，全局指令，全局混入，给vue的原型加方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue的生命周期</title>
      <link href="/2023/03/02/25mndVlvgeN3qP5X/"/>
      <url>/2023/03/02/25mndVlvgeN3qP5X/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h3 id="初始化的整个流程"><a href="#初始化的整个流程" class="headerlink" title="初始化的整个流程"></a>初始化的整个流程</h3><p>1.初始化生命周期，事件 –&gt; 2.beforeCreate() –&gt; 3.初始化数据监测,数据代理 –&gt; 4.created()<br>–&gt; 5.vue开始解析模板 生成虚拟dom –&gt; 6.beforeMount() –&gt; 7.内存中编译好的模板替换到浏览器的页面里 –&gt; 8. mounted()</p><h3 id="发生update"><a href="#发生update" class="headerlink" title="发生update"></a>发生update</h3><p>1.beforeUpdate():这一步执行的时候，页面中显示的数据还是旧数据，data里的数据是最新的，但是尚未同步。<br>2.根据data中最新的数据在内存中重新渲染出一份最新的内存dom树，当最新的内存dom树被更新之后，把新的dom树渲染到真实页面中，完成了数据从data到view的更新<br>updated():此时页面和data的数据已经保持了同步，都是最新数据</p><h3 id="执行销毁"><a href="#执行销毁" class="headerlink" title="执行销毁"></a>执行销毁</h3><p>1.beforeDestroy():vue进行到了销毁阶段，但是此时所有的data method都处于可用状态<br>2.摧毁组件，事件监听<br>3.destroyed():完全销毁，所有方法指令过滤器都不可用</p><h3 id="生命周期发生的事件"><a href="#生命周期发生的事件" class="headerlink" title="生命周期发生的事件"></a>生命周期发生的事件</h3><p>beforeCreate():这个时候，在实例被完成创建出来，el和data都没有初始化，不能访问data、method，一般在这个阶段不进行操作。</p><p>created():这个时候，vue实例中的data、method已被初始化，属性也被绑定，但是此时还是虚拟dom，真是dom还没生成，$el 还不可用。这个时候可以调用data和method的数据及方法，created钩子函数是最早可以调用data和method的，故一般在此对数据进行初始化。</p><p>beforeMount():此时模板已经编译完成，但还没有被渲染至页面中（即为虚拟dom加载为真实dom），此时el存在则会显示el。在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。当vue实例中，el为挂载目标，未对el进行定义，则this.el显示undefined，但页面中存在template也能识别挂载目标，因为template可以被看成占位符。如果对其进行定义则显示<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，故所以，beforeMount读取不了真实的el，在mounted才能读取到真实的el，因为el只有渲染完成后才会存在。这里讲的el是真实的el。在真实的el之前存在前，在beforeMount中的其实是页面中的#app，是挂载的目标。</p><p>mounted():此时模板已经被渲染成真实DOM，用户已经可以看到渲染完成的页面，页面的数据也是通过双向绑定显示data中的数据。 这实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在我们的内存中，一动不动。</p><p>beforeUpdate():更新前状态（view层的数据变化前，不是data中的数据改变前），重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。只有view上面的数据变化才会触发beforeUpdate和updated，仅属于data中的数据改变是并不能触发。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue的组件与构造函数</title>
      <link href="/2023/03/02/WwUBeygAXAwT78IC/"/>
      <url>/2023/03/02/WwUBeygAXAwT78IC/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="vue的组件声明"><a href="#vue的组件声明" class="headerlink" title="vue的组件声明"></a>vue的组件声明</h2><p>定义组件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const componentName = Vue.extend(&#123;</span><br><span class="line">    template:`&lt;div&gt;12345&lt;/div&gt;`//html</span><br><span class="line">    data()&#123;</span><br><span class="line">        //组件的data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&#x27;#root&#x27;，</span><br><span class="line">    data:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        componentName:componentName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>const componentsName = vue.extend(options)</code> 可以简写为 <code>const componentsName = optiions</code></p><h2 id="vue组件嵌套"><a href="#vue组件嵌套" class="headerlink" title="vue组件嵌套"></a>vue组件嵌套</h2><p>定义在那里就在哪里引入 比较简单</p><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>.vue结尾的文件<br>引入别的组件：import里引入 然后在components里面注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//App.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import School from &#x27;./School&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        School</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vueComponent"><a href="#vueComponent" class="headerlink" title="vueComponent"></a>vueComponent</h2><p>前面定义的组件的本质（数据类型）到底是什么？<br>组件的本质是VueComponent函数，是由vue.extend生成的。<br>我们调用组件的时候，vue会帮我们调用vuecomponent函数。每次调用vue.extend的时候，都会调用一个全新的vueComponent</p><h2 id="vm和vc的区别"><a href="#vm和vc的区别" class="headerlink" title="vm和vc的区别"></a>vm和vc的区别</h2><p>vm是vue的实例对象，vc是组件的实例对象<br>vm需要声明一个el 但是vc不需要<br>vm的data必须是函数，所以才可以维护一份被返回对象独立的拷贝</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.set的详细分析和数据监测</title>
      <link href="/2023/02/28/cEUIRQynKYWg4IB2/"/>
      <url>/2023/02/28/cEUIRQynKYWg4IB2/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当实现定义好了data里的一组数据或者对象里的属性，后面想要添加新的属性或者新的对象的时候，可以使用Vue.set()</p><p>例如data里的student对象，如果想要添加一个sex属性，想当然可能会使用<code>this.student.sex = &#39;male&#39;</code>这种赋值语句，但是这种赋值语句语句vue不会添加setter和getter函数，便不是响应式的，所以不会在页面中显示出来；可以使用<code>Vue.set(this.student,&#39;sex&#39;,&#39;male&#39;)</code>来进行属性的添加</p><p>Vue.set() 是添加响应式属性<br>target：需要向哪个目标对象添加</p><p>key：需要添加的属性名</p><p>val：需要添加的属性的值</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要向 vm实例对象中添加属性 或 直接向 vm._data 中添加属性<br>说明白点 data里那么多数据， 不能直接添加到data的根路径里，只能用来添加到data里对象的属性里</p><h2 id="对数组的数据监测"><a href="#对数组的数据监测" class="headerlink" title="对数组的数据监测"></a>对数组的数据监测</h2><p>vue规定，数组直接发生数据改变（意思就是直接等）不能调用监控<br>push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>Vue.set() 或 vm.$set()<br>这些api可以调用数据监测，进一步更新到你的页面里</p><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>在数组尾部添加一个数据，返回值是新的长度</p><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>在数组尾部删除一个数据，返回值是数组的最后一个元素</p><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h4><p>删除数组的第一个值，并且返回新的第一个值</p><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h4><p>对数组的开头添加一个或更多元素，并返回新的长度</p><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>splice(index,howmany,item1, …, itemX) 方法向/从数组中添加/删除项目，然后返回被删除的项目<br>第一个参数：表示从哪个索引位置（index）添加/删除元素<br>第二个参数：要删除的项目数量。如果设置为 0，则不会删除项目。<br>第三个参数：可选。向数组添加的新项目</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>原列表进行排序，如果指定参数，则使用比较函数指定的比较函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sortNumber (a, b) &#123;</span><br><span class="line">  return a - b</span><br><span class="line">&#125;</span><br><span class="line">let arr = [10,5,40,25,1000,1]</span><br><span class="line">arr.sort(sortNumber)</span><br><span class="line">console.log(arr) // [1, 5, 10, 25, 40, 1000]</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p>反向处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue computed 和watch详细分析与使用</title>
      <link href="/2023/02/28/dNvnVBdwos4VWSrG/"/>
      <url>/2023/02/28/dNvnVBdwos4VWSrG/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>如期名，computed是计算属性，被计算出来的属性<br>官方文档中有这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里好像是method也可以完成需求，但是computed具有缓存属性，多次调用，vue会判断computed的依赖值是否修改，如果没有修改则只执行一次，后面会沿用这个结果；但是method是调用一次就会直接执行，造成资源浪费</p><p>computed监控的是自己定义的变量，比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化。这里的这个总金额使用computed属性来进行计算是最好的选择。</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch主要是用来监控vue实例的变化，watch监视的数据必须在data里定义<br>watch只能用来监听一个对象或者一个值，无法监控对象的一个属性<br>watch 不支持缓存，数据变，直接会触发相应的操作<br>watch 支持异步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue常用指令、事件修饰符和自定义指令</title>
      <link href="/2022/09/29/4SHM2ptWgjuslFop/"/>
      <url>/2022/09/29/4SHM2ptWgjuslFop/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="常用指令及作用"><a href="#常用指令及作用" class="headerlink" title="常用指令及作用"></a>常用指令及作用</h2><p><code>v-on</code> 用来给目标元素绑定事件的，事件的类型由参数决定。接下来，将举一个v-on用法的小例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;clickHandler&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>当然 这里一般简写成 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;clickHandler&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><code>v-bind</code> 用来给属性绑定一个变量 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el:&#x27;.app&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        url:&quot;https://www.baidu.com&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a v-bind:href=&quot;url&quot;&gt;click me&lt;/a&gt;</span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure><p>当然也有简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a :href=&quot;url&quot;&gt;click me&lt;/a&gt;</span><br><span class="line">&lt;/div&gt; </span><br></pre></td></tr></table></figure><p><code>v-model</code> <code>v-if</code> <code>v-show</code> <code>v-for</code> <code>v-else</code> 不解释了 太常用了</p><h2 id="没那么常用的指令和作用"><a href="#没那么常用的指令和作用" class="headerlink" title="没那么常用的指令和作用"></a>没那么常用的指令和作用</h2><p><code>v-text</code> 用来绑定数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这俩显示的效果是一样的，但是v-text会把值的内容拿来替换所有div里的内容，如果div里有东西全部都不显示</p><p><code>v-html</code>  绑定数据 和v-text的区别就是v-html可以解析标签<br>安全性问题：容易被利用进行跨站脚本攻击</p><p><code>v-cloak</code> 配合css，可以做到延迟加载并且不会出现插值语法</p><p><code>v-once</code> 只加载一次 后面插值语法内容更新的时候不会发生改变，即只更新一次</p><p><code>v-pre</code> 跳过vue节点的编译过程</p><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>1.prevent 阻止默认事件<br>2.stop 阻止事件冒泡<br>3.once 事件只触发一次<br>4.capture 使用事件的捕获形式<br>5.self 只有event.target是当前元素时才触发事件<br>6.passive 事件的默认行为立即执行，无需等待回调或执行完毕</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><p>写个例子，看看就懂了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-big=&quot;n&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            n:1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">        big(element,binding)&#123;</span><br><span class="line">            element.innerText = binding.value*10</span><br><span class="line">            //element是元素，即dom节点</span><br><span class="line">            //binding是绑定，一般使用binding.value 获取绑定的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>指令所在的模板被重新解析的时候就会重新调用指令</p><h3 id="对象式"><a href="#对象式" class="headerlink" title="对象式"></a>对象式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input fbind:value=&quot;n&quot;&gt;&lt;/input&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            n:1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    directives:&#123;</span><br><span class="line">        fbind:&#123;</span><br><span class="line">            bind(element,binding)&#123;</span><br><span class="line">                //这里写绑定时需要进行的动作</span><br><span class="line">            &#125;</span><br><span class="line">            insert(element,binding)&#123;</span><br><span class="line">                //插入元素时需要进行的动作</span><br><span class="line">            &#125;</span><br><span class="line">            update(element,binding)&#123;</span><br><span class="line">                //更新时进行的动作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE中key的处理</title>
      <link href="/2022/09/27/5gPRXWxmruWJqCeQ/"/>
      <url>/2022/09/27/5gPRXWxmruWJqCeQ/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="列表中使用key"><a href="#列表中使用key" class="headerlink" title="列表中使用key"></a>列表中使用key</h2><p>key是vue将虚拟dom转化为真实dom的时候会把vue处理掉，所以看不见key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &#123;&#123;p.name&#125;&#125; -- &#123;&#123;p.age&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果需要在person数组里前面添加一个数据，因为下标发生了改变，会发生数据错乱。</p><h2 id="key的工作原理-和-diff算法"><a href="#key的工作原理-和-diff算法" class="headerlink" title="key的工作原理 和 diff算法"></a>key的工作原理 和 diff算法</h2><p>对于初始数据 {id:’001’,name:’张3’,age:’18’},{id:’002’,name:’张4’,age:’18’},{id:’003’,name:’张5’,age:’18’}<br>vue在拿到后生成了虚拟dom如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&quot;0&quot;&gt;张3-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;1&quot;&gt;张4-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;2&quot;&gt;张5-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure><p>数据添加在数组头的时候，现在的数据是：<br>{id:’004’,name:’张2’,age:’18’}<br>{id:’001’,name:’张3’,age:’18’}<br>{id:’002’,name:’张4’,age:’18’}<br>{id:’003’,name:’张5’,age:’18’}</p><p>生成的新虚拟dom为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&quot;0&quot;&gt;张2-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;1&quot;&gt;张3-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;2&quot;&gt;张4-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br><span class="line">&lt;li key=&quot;3&quot;&gt;张5-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure><p>但是vue不会直接将虚拟dom转化成真实dom，vue将新虚拟dom和旧的虚拟dom进行对比，通俗来讲流程是这样的：<br>首先看新的虚拟dom的key=0的一行，发现key为0，回去旧dom判断key=0的是否存在，而这里是存在的；再观察dom里有两个节点，一个文本（张3-18）,一个input框，文本对比张3-18和张2-18，发现发生了改变，于是vue拿新数据覆盖了旧数据； 对比input节点发现一样（因为输入的数据在真实dom里，现在比对的是虚拟dom，在内存中）；<br>对于对比结果不一致的，于是决定不复用；对于对比结果一致的，直接复用。</p><h2 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h2><p>key是虚拟dom对象的标识，当状态中的数据发生变化的时候，vue会根据新数据生成新的虚拟dom，随后vue进行新的虚拟dom与旧的虚拟dom的对比，按照规则去和留。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM</title>
      <link href="/2022/07/26/M8GXOdNaXupXHGTA/"/>
      <url>/2022/07/26/M8GXOdNaXupXHGTA/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>定义：Document Object Model，文档对象模型。<br>用途：使用JS操作web页面。<br>Document –&gt; 文档表示的是整个html网页文档<br>Object   –&gt; 将网页中的每一个部分都转化成了对象，例如标签，内容，都可以是对象。<br>Model    –&gt; 使用面向对象的方式操作对象</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>定义：node - 构成HTML文档最基本的单元<br>常用有四类：<br> -文档节点：整个HTML文档<br> -元素节点：HTML文档中的HTML标签<br> -属性节点：元素的属性 例如id name<br> -文本节点：HTML标签中的文本内容</p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;这是一个按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var dom = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">    //修改按钮文字</span><br><span class="line">    dom.innerHTML = &quot;这是修改过的按钮&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义正则表达式</title>
      <link href="/2022/07/26/lGbgvQJRtplLyffx/"/>
      <url>/2022/07/26/lGbgvQJRtplLyffx/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="创建自定义正则表达式"><a href="#创建自定义正则表达式" class="headerlink" title="创建自定义正则表达式"></a>创建自定义正则表达式</h2><p>判断字符串里是否有aaa</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = /aaa/</span><br><span class="line">console.log(reg.test(&#x27;abc&#x27;)) //false</span><br></pre></td></tr></table></figure><p>如果字符太长，会影响整体美观，可以使用{num}来代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var reg = /a&#123;3&#125;/ //判断是否有3个a</span><br><span class="line">var reg1 = /ab&#123;3&#125;/ //判断是否有abbb</span><br><span class="line">var reg2 = /(ab)&#123;3&#125;/ //判断是否有ababab</span><br><span class="line">var reg3 = /ab&#123;1,3&#125;/ 判断是否有1个a+1到3个b</span><br><span class="line">var reg4 = /ab&#123;3, &#125;/判断是否有1个a+3个以上的b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(reg.test(&#x27;abc&#x27;)) //false</span><br></pre></td></tr></table></figure><h3 id="检查是否由哪个字母开头或者结尾"><a href="#检查是否由哪个字母开头或者结尾" class="headerlink" title="检查是否由哪个字母开头或者结尾"></a>检查是否由哪个字母开头或者结尾</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^a/ //以a开头</span><br><span class="line">var reg = /a$/ //以a结尾</span><br><span class="line">var reg = /^a$/ //以a开头且以这个a结尾 换句话说是完全匹配正则表达式</span><br><span class="line">var reg = /^[0-9]/ //以数字开头 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap6 路由</title>
      <link href="/2022/07/12/CD636bLcU1pXCKer/"/>
      <url>/2022/07/12/CD636bLcU1pXCKer/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>在新建组件的时候选择add route 此时会发现多了一个app-routing.module，在这个文件里引入我们声明的其他组件，并且配置路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const routes: Routes = [</span><br><span class="line"></span><br><span class="line">    //格式是path:&#x27;路径名&#x27;,component:组件名</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        path:&#x27;home&#x27;,component:HomeComponent</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        path:&#x27;news&#x27;,component:NewsComponent</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        path:&#x27;product&#x27;,component:ProductComponent</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        path:&#x27;**&#x27;,//任意的路由，如果前面的都不能匹配，则和这个匹配</span><br><span class="line">        redirectTo:&#x27;homes&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置路由后,在根组件下会有一个route-outlet的标签，此时我们访问/home时，home组件的内容就会出现在这个route-outlet标签里。<strong>换句话说，你路由到哪个组件，组件内容就会在根组件的route-outlet的位置显示。</strong></p><h4 id="使用a标签跳转"><a href="#使用a标签跳转" class="headerlink" title="使用a标签跳转"></a>使用a标签跳转</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装snippet之后直接输入ng-routelink就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a routeLink=&quot;/home&quot;&gt;首页&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="实现选中特效"><a href="#实现选中特效" class="headerlink" title="实现选中特效"></a>实现选中特效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a routeLink=&quot;/home&quot; routeLinkActive=&quot;className&quot;&gt;首页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//.css</span><br><span class="line">.className&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由传值和动态路由"><a href="#路由传值和动态路由" class="headerlink" title="路由传值和动态路由"></a>路由传值和动态路由</h2><h4 id="Get传值"><a href="#Get传值" class="headerlink" title="Get传值"></a>Get传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//A页面跳转到B页面</span><br><span class="line"></span><br><span class="line">//A页面的html</span><br><span class="line">//跳转到aid为key的页面</span><br><span class="line">&lt;a routeLink=&quot;/newsDetail&quot; [queryParams]=&quot;&#123;aid:key&#125;&quot;&gt;跳转到新闻详情&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//B页面接收值</span><br><span class="line">import &#123; ActiveRoute &#125; from &#x27;@angular/route&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constructor(public route:ActiveRoute)&#123;&#125;</span><br><span class="line"></span><br><span class="line">ngOnInit()&#123;</span><br><span class="line">    this.route.queryParams.subscribe((result)=&gt;&#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态路由传值"><a href="#动态路由传值" class="headerlink" title="动态路由传值"></a>动态路由传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//路由配置页</span><br><span class="line">path:&#x27;newsDetail/:aid&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//A页面的html</span><br><span class="line">&lt;a routeLink=&quot;[&#x27;/newsDetail/&#x27;,key]&quot;&gt;跳转到新闻详情&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//B页面的ts</span><br><span class="line"> this.route.params.subscribe((result)=&gt;&#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JS跳转"><a href="#JS跳转" class="headerlink" title="JS跳转"></a>JS跳转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router &#125; from &#x27;@angular/router&#x27;</span><br><span class="line"></span><br><span class="line">this.router.navigate([&#x27;/newsdetail/&#x27;, &#x27;1234&#x27;])</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap5 与服务器交互</title>
      <link href="/2022/07/11/MaeISxN72jT02Gci/"/>
      <url>/2022/07/11/MaeISxN72jT02Gci/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="使用get请求数据"><a href="#使用get请求数据" class="headerlink" title="使用get请求数据"></a>使用get请求数据</h2><p>首先在app.module中引入httpClientModule,然后在imports中声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; httpClientModule &#125; from &#x27;@angular/common/http&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imports:[</span><br><span class="line">    HttpClientModule</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>再在需要使用请求数据的地方引入httpclient与调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HttpClient &#125; from &#x27;@angular/common/http&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constructor(public http:HttpClient)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData()&#123;</span><br><span class="line">    let api = &#x27;xxx&#x27;</span><br><span class="line">    this.http.get(api).subscribe((result)=&gt;&#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用POST提交数据"><a href="#使用POST提交数据" class="headerlink" title="使用POST提交数据"></a>使用POST提交数据</h2><p>大体和GET相同，但是POST需要多引入一个httpheader头文件,因为在进行POST请求的时候需要同时传一个header</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POSTDATA()&#123;</span><br><span class="line">    let api = &#x27;xxx&#x27;</span><br><span class="line">    const httpOptions = &#123;headers: new HttpHeaders(&#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;&#125;)&#125;</span><br><span class="line">    this.http.post(api,&#123;&quot;username&quot;:&quot;123&quot;,&quot;age&quot;:&quot;12&quot;&#125;,httpOptions).subscribe((response)=&gt;&#123;</span><br><span class="line">        console.log(response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用jsonp获取服务器数据"><a href="#使用jsonp获取服务器数据" class="headerlink" title="使用jsonp获取服务器数据"></a>使用jsonp获取服务器数据</h2><p>如果存在跨域，就使用jsonp来获取服务器数据。</p><p>首先，为什么会存在跨域？比如说域名是localhost，使用的协议是https，端口是5777，访问127.0.0.1:3000的服务器就会产生跨域。如果服务器不支持跨域，那么发出的GET或者POST请求都不可以获取到数据。<strong>只要协议、端口、域名有一个不一样，就属于不同源，那么访问时就可能产生跨域问题。</strong></p><p>这里使用的解决方案是使用jsonp解决跨域问题<br>解决的原理：jsonp相当于是通过callback的xxx方法把服务器的数据传回本地</p><p>如何判断服务器支不支持jsonp？<br>在接口后写个callback = xxx 如果显示出了:xxx 说明支持jsonp</p><ol><li>在app.module里引入 httpClientjsonModule</li><li>如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let api = &#x27;xx&#x27;</span><br><span class="line">this.http.jsonp(api,&#x27;callback&#x27;).subscribe((result)=&gt;&#123;</span><br><span class="line">    console.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用axios-第三方-来请求数据"><a href="#使用axios-第三方-来请求数据" class="headerlink" title="使用axios(第三方)来请求数据"></a>使用axios(第三方)来请求数据</h2><p>通过npm安装<br><code>npm install axios --save</code><br><code>import &#123;axios&#125; from &#39;axios&#39;</code><br>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axiosGet(api)&#123;</span><br><span class="line"></span><br><span class="line">    //异步拿数据</span><br><span class="line">    axios.get(api)</span><br><span class="line">    .then(function (response)  &#123;</span><br><span class="line">        console.log(response)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记  --Chap4 生命周期函数与异步编程</title>
      <link href="/2022/07/11/XugN5JDCzLhCKw0b/"/>
      <url>/2022/07/11/XugN5JDCzLhCKw0b/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p> 生命周期函数就是在组件的状态发生改变，例如创建、更新、销毁时调用的一系列方法。Angular创建一个组件时，会调用如下的函数</p><ul><li>constructor()        : 使用简单的值对局部变量进行初始化，注意，这个函数并非生命周期函数</li><li>ngOnchange()         : Angular接受数据绑定时调用 </li><li>ngOnInit()           : Angular第一次显示数据绑定和设置指令/组件的输入属性后调用。一般请求数据放在这里</li><li>ngDocheck()          : 检测,在变更周期中调用。</li><li>ngAfterViewInit()    : 初始化完视图之后调用。做dom操作可以放在这里。</li><li>ngAfterViewChecked() : 视图变更后调用</li><li>ngDestroy()          : 组件销毁时调用</li></ul><h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>ngOnchange()在有父子传值的时候才会触发，如果没有父子组件通讯，ngOnchange()不会触发。<br>几个check函数在数据绑定之后会再触发一次，举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ts文件</span><br><span class="line">public title:any = &#x27;这是一个title&#x27;;</span><br></pre></td></tr></table></figure><p>在视图加载后进行title的数据绑定，会再触发一次三个check函数。所以如果console一下就可以发现，声明周期函数除了Onchange没触发一外全部触发一次之后，三个check函数还会再触发一次。中途如果数据改变了，几个check函数也会触发。</p><h2 id="RXJS异步"><a href="#RXJS异步" class="headerlink" title="RXJS异步"></a>RXJS异步</h2><p>Angular引入RXJS的目的就是为了让异步变简单</p><h4 id="使用observable"><a href="#使用observable" class="headerlink" title="使用observable"></a>使用observable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let stream = new Observable(observer =&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        observer.next(&#x27;get timeout data&#x27;);</span><br><span class="line">    &#125;,2000)</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">stream.subscribe(value =&gt;&#123;</span><br><span class="line">    console.log(value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看上去和promise十分相似，实际上rxjs的功能更加强大。</p><h4 id="超时取消订阅"><a href="#超时取消订阅" class="headerlink" title="超时取消订阅"></a>超时取消订阅</h4><p>使用unsubscribe，超时后取消返回数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GetRxjsData()&#123;</span><br><span class="line">    let stream = new Observable(observer =&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        observer.next(&#x27;get timeout data&#x27;);</span><br><span class="line">    &#125;,2000)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var stream = this.getRxjsData()</span><br><span class="line">var d = stream.subscribe((data)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        d.unsubscribe();</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="反复调用"><a href="#反复调用" class="headerlink" title="反复调用"></a>反复调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getRxjsIntervalData()&#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    return new Observable(observer =&gt;&#123;</span><br><span class="line">        setInterval(()=&gt;&#123;</span><br><span class="line">            var name = &#x27;good&#x27;+count;</span><br><span class="line">            observer.next(name)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(this.getRxjsIntervalData())</span><br></pre></td></tr></table></figure><h2 id="Rxjs中的工具函数–map-amp-filter"><a href="#Rxjs中的工具函数–map-amp-filter" class="headerlink" title="Rxjs中的工具函数–map&amp;filter"></a>Rxjs中的工具函数–map&amp;filter</h2><p>首先安装rxjs模块和导入map,filter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install rxjs-compat</span><br><span class="line">import &#123;map,filter&#125; from &#x27;rxjs/operators&#x27;;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 筛选出可以被2整除的value</span><br><span class="line">getRxjsIntervalData()&#123;</span><br><span class="line">    let count = 0;</span><br><span class="line">    return new Observable(observer =&gt;&#123;</span><br><span class="line">        setInterval(()=&gt;&#123;</span><br><span class="line">            var name = &#x27;good&#x27;+count;</span><br><span class="line">            observer.next(name)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let stream = this.getRxjsIntervalData()</span><br><span class="line">stream.pipe(</span><br><span class="line">    filter(val=&gt;val%2 == 0)).subscribe(value=&gt;&#123;</span><br><span class="line">    console.log(&quot;filter&quot;+value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream.pipe(</span><br><span class="line">    map(value=&gt;&#123;</span><br><span class="line">    return value*value;</span><br><span class="line">&#125;)</span><br><span class="line">).subscribe(value=&gt;&#123;</span><br><span class="line">    console.log(&quot;map&quot;+value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap 3 Dom操作与父子组件通讯</title>
      <link href="/2022/07/08/xnZVKaU9ygUYNAn2/"/>
      <url>/2022/07/08/xnZVKaU9ygUYNAn2/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Dom操作"><a href="#Dom操作" class="headerlink" title="Dom操作"></a>Dom操作</h2><p>Angular中也可以对dom进行操作</p><h4 id="使用原生js方法"><a href="#使用原生js方法" class="headerlink" title="使用原生js方法"></a>使用原生js方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;div id=&quot;box1&quot;&gt;1234&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//ts 将id为box1的颜色变为红色</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    var boxDom:any = document.getElementById(&#x27;box1&#x27;)</span><br><span class="line">    boxDom.style.color = red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Angular自带的dom操作"><a href="#使用Angular自带的dom操作" class="headerlink" title="使用Angular自带的dom操作"></a>使用Angular自带的dom操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//html</span><br><span class="line">&lt;div #Box1&gt;</span><br><span class="line">    我是一个叫做Box1的DOM节点</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//ts</span><br><span class="line"></span><br><span class="line">//头文件先引入</span><br><span class="line">import &#123; viewchild &#125; from &#x27;@angular/core&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在constructor上面构造</span><br><span class="line"></span><br><span class="line">@viewChild(&#x27;Box1&#x27;)Mybox:any;</span><br><span class="line"></span><br><span class="line">//还是在视图加载后的生命周期函数里进行dom操作，因为视图加载后dom才加载完成</span><br><span class="line">ngAfterViewInit()&#123;</span><br><span class="line">    console.log(this.Mybox)</span><br><span class="line">    //把box1的字体颜色变成红色</span><br><span class="line">    this.Mybox.nativeElement.style.color = &quot;red&quot;;</span><br><span class="line">    //打印dom节点</span><br><span class="line">    console.log(this.Mybox.nativeElement.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上，viewchild是父子组件之间通讯使用的工具，可以使用viewchild对子组件的方法进行访问</p><h2 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h2><h4 id="父组件使用viewchild调用子组件里的方法"><a href="#父组件使用viewchild调用子组件里的方法" class="headerlink" title="父组件使用viewchild调用子组件里的方法"></a>父组件使用viewchild调用子组件里的方法</h4><p>在使用viewChild对整个子组件进行获取后，直接使用this.xxx就可以对整个子组件进行访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@viewChild(&#x27;Box1&#x27;)Mybox:any;</span><br><span class="line"></span><br><span class="line">//使用getChild函数对子组件的run方法进行访问</span><br><span class="line">getChild()&#123;</span><br><span class="line">    this.Mybox.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父组件给子组件传值，使用input"><a href="#父组件给子组件传值，使用input" class="headerlink" title="父组件给子组件传值，使用input"></a>父组件给子组件传值，使用input</h4><p>父组件<code>(home)</code>在调用子组件<code>(header)</code>的时候将自己的msg传到子组件，子组件再进行调用，例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//home组件的html</span><br><span class="line">//方法也可以直接这样传 [run]=&quot;run&quot; 子组件就可以直接使用run方法了</span><br><span class="line">//甚至可以把整个自己传过去 [home]=&quot;this&quot;</span><br><span class="line">&lt;app-header [title]=&quot;title&quot;&gt;我是header组件，也是子组件&lt;/app-header&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//home组件的ts</span><br><span class="line">public msg:any=&#x27;我是父组件的title&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//header组件的ts 引入input</span><br><span class="line">import &#123; Input &#125; from &#x27;Angular/core&#x27;</span><br><span class="line"></span><br><span class="line">//下面使用input</span><br><span class="line">@input()title:any;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//header组件的html可以直接调用title，在ts里也可以用this直接调用</span><br><span class="line">&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line">//输出我是父组件的title</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web中页面缓存的使用方法</title>
      <link href="/2022/07/08/qDdyTOpLgeugPVyT/"/>
      <url>/2022/07/08/qDdyTOpLgeugPVyT/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>LocalStorage是长期储存数据的方法，它拥有永久的生命周期,除非是主动删除数据,否则就算是关闭页面,localStorage保存的数据也不会消失。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>LocalStorage有四个方法:储存数据<code>setItem</code>，删除数据<code>removeItem</code>，取出数据<code>getItem</code>，清除数据<code>clear</code>,下面列举几个常用情况</p><h4 id="储存新数据"><a href="#储存新数据" class="headerlink" title="储存新数据"></a>储存新数据</h4><p>使用setItem来储存数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// key为你保存再localStorage中这个玩意的名字，你取名叫王大锤就在localStorage里叫王大锤</span><br><span class="line">localStorage.setItem(key,JSON.stringify(value))</span><br><span class="line">//value是你要保存的值</span><br></pre></td></tr></table></figure><p>因为localStorage仅支持存储字符类型的数据，所以先将可能为数组或对象的数据转化为JSON字符串，再进行存储。</p><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>使用getItem来获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取在localstorage里名字叫key的数据</span><br><span class="line">localStorage.getItem(key)</span><br></pre></td></tr></table></figure><p>通常要将取出的数据JSON.parse一下把他变回原来的样子，所以一般这么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(localStorage.getItem(key) || &#x27;0&#x27;)</span><br></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>其实就是修改后再存一遍，用setItem 代码我就不写了</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>使用removeItem 和取出一样 get换成remove就行 代码也不写了</p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>sessionStorage 的生命周期是仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>同localStorage 把localStorage换成sessionStorage就行</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>待施工</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap 2 双向数据绑定与服务</title>
      <link href="/2022/07/08/oBxcnSMUomsktSq3/"/>
      <url>/2022/07/08/oBxcnSMUomsktSq3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="事件和双向数据绑定"><a href="#事件和双向数据绑定" class="headerlink" title="事件和双向数据绑定"></a>事件和双向数据绑定</h2><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>Angular里提供了点击事件，写法和vue里大差不差，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button (click)=&quot;getData($event)&quot;&gt;点击触发getData函数&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>如果想要加上监听，在括号中填入$event；这个getData方法写在module里的ngOnInit后面，方法之间不用加逗号</p><h4 id="双向数据绑定步骤"><a href="#双向数据绑定步骤" class="headerlink" title="双向数据绑定步骤"></a>双向数据绑定步骤</h4><p>首先，双向数据绑定只是针对表单，想要使用双向数据绑定需要引入formsmodule，具体步骤如下</p><p>1.引入Formsmodule</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Formsmodule &#125; from &#x27;@Angular/forms&#x27;</span><br></pre></td></tr></table></figure><p>2.在想要使用双向数据绑定的地方写入ngmodel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; value=&quot;1&quot; [(ngModel)]=&quot;gender&quot; id=&quot;male&quot;&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; value=&quot;2&quot; [(ngModel)]=&quot;gender&quot; id=&quot;female&quot;&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：在select中使用双向数据绑定时写在select里</strong></p><h2 id="Angular中的服务"><a href="#Angular中的服务" class="headerlink" title="Angular中的服务"></a>Angular中的服务</h2><h4 id="什么是服务"><a href="#什么是服务" class="headerlink" title="什么是服务"></a>什么是服务</h4><p>服务是公共的方法。组件A想要使用方法a,组件B也想要使用方法a，这时方法a就可以封装进一个服务里，组件A、B只需要对服务进行引入就可以了。</p><h4 id="创建一个服务"><a href="#创建一个服务" class="headerlink" title="创建一个服务"></a>创建一个服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g service serviceName</span><br></pre></td></tr></table></figure><h4 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h4><p>在app.module里的provider里写入服务名称,同时import一下,然后再在需要使用这个服务的地方引入该服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;storageService&#125; from &#x27;./service/storage.service&#x27;</span><br></pre></td></tr></table></figure><h4 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h4><p>在需要使用的组件的module.ts文件里的构造函数中引入服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(public storage:storageService)&#123;</span><br><span class="line">    let serviceTest = this.storage.get()//get是在服务中声明的方法</span><br><span class="line">    console.log(serviceTest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记 --Chap 1 常用命令与组件操作</title>
      <link href="/2022/07/07/GxVKBgUYIwmThpXh/"/>
      <url>/2022/07/07/GxVKBgUYIwmThpXh/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Angular目录分析"><a href="#Angular目录分析" class="headerlink" title="Angular目录分析"></a>Angular目录分析</h2><p>Angular是以组件为核心的框架，做的开发大多是和组件相关。而组件开发大多是在<em><strong>组件名/src/app</strong></em>里进行开发。<br>其中<strong>app-routing.module</strong>是用来配置路由,<strong>app.component.html</strong>是根组件页面,<strong>app.component.css</strong>是根组件样式表,<strong>app.module.ts</strong>是组件的根模块，告诉组件如何组装应用</p><p><em><strong>src/assets</strong></em>常用来放置一些静态的数据，例如图片等</p><p><em>src/enviornment</em>该目录下是环境的配置</p><p><em>favicon.ico</em>是项目的图标icon</p><p><em>index.html</em>是项目的入口html文件</p><p><em>style.scss</em>用来防止一些全局样式，按需写入</p><p><del>没加粗的表示没什么用</del></p><h2 id="Angular常用命令"><a href="#Angular常用命令" class="headerlink" title="Angular常用命令"></a>Angular常用命令</h2><h3 id="创建一个新项目"><a href="#创建一个新项目" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h3><p><code>ng new xxx</code></p><h3 id="创建一个新组件"><a href="#创建一个新组件" class="headerlink" title="创建一个新组件"></a>创建一个新组件</h3><p><code>ng g c 组件名</code> or <code>ng g c 目录文件夹/组件名</code></p><p>比如我想创建一个在components文件夹下、名为news的组件，我可以这么创建<code>ng g c components/news</code></p><h3 id="挂载后运行"><a href="#挂载后运行" class="headerlink" title="挂载后运行"></a>挂载后运行</h3><p><code>ng serve --open</code></p><p>输入以上代码后访问localhost:4000可以打开你写的网页，打开速度很快，修改代码之后直接保存代码，网页也会立刻把修改的内容呈现出来，响应的很快</p><h3 id="创建一个新服务"><a href="#创建一个新服务" class="headerlink" title="创建一个新服务###"></a>创建一个新服务###</h3><p><code>ng g service serviceName</code> or <code>ng g service route/serviceName</code></p><h2 id="开始写代码吧"><a href="#开始写代码吧" class="headerlink" title="开始写代码吧"></a>开始写代码吧</h2><p><strong>Angular定义的各个组件之间可以直接调用。</strong><br>例如我新建了一个news组件，又新建了一个home组件，我可以直接在home文件夹里的html模板里调用<code>&lt;app-news&gt;&lt;/app-news&gt;</code>标签来调用news组件。</p><p><strong>Angular在定义数据的时候需要声明数据类型。</strong><br><code>public username:string = &#39;王大锤&#39;</code>                —- 字符串</p><p><code>public listName:any[]=[&#39;王大锤&#39;,&#39;李大锤&#39;,&#39;张大锤&#39;]</code> —- 数组_1</p><p><code>public arr=[&#39;1111&#39;,&#39;2222&#39;,&#39;33333&#39;];</code> —- 数组_2</p><p><code>public items:Array&lt;string&gt;=[&#39;我是第一个新闻&#39;,&#39;我是第二个新闻&#39;];</code> —- 数组_3</p><p>其中，数组有三种声明方式。推荐使用第一种。</p><p><strong>Angular在定义任何变量的时候建议都设置变量类型，甚至包括方法的形参，不设置的话可能会报错。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetData(e:any)&#123;</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular不同于其他框架，声明变量时应该声明在正在使用的组件的components.ts文件中的export出的OnInit()函数里，写在constructor函数的正上方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export class NewsComponent implements OnInit &#123;</span><br><span class="line">    //变量声明在下方</span><br><span class="line">    public username:string = &#x27;王大锤&#x27;</span><br><span class="line"></span><br><span class="line">    //这是构造函数，页面刚刚准备加载时候调用，是最先调用的函数</span><br><span class="line">    constructor() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //页面初始化后调用，注意此时视图还没加载完成，无法完成dom操作</span><br><span class="line">    ngOnInit(): void &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //函数声明在这里</span><br><span class="line">  GetData(key:any)&#123;</span><br><span class="line">    return key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件操作（循环，if判断等）"><a href="#组件操作（循环，if判断等）" class="headerlink" title="组件操作（循环，if判断等）"></a>组件操作（循环，if判断等）</h2><p><strong>循环操作</strong>很简单，在加载了Angular对应插件后直接输入ngfor就可以完成 写出来是这样的</p><p><code>ngFor = &quot;let item of List;let key = index&quot;</code></p><p>其中key不是一定要声明的，List是数组名，就是我们在OnInit里定义的数组变量。</p><p><strong>条件判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngIf = &quot;true&quot;&gt;这是angular中的条件判断&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意了,Angular没有ngElse <del>至少Angular7没有</del> 所以需要否定判断的自行加!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div *ngIf = &quot;!false&quot;&gt;这是angular中的else条件判断&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果想要让数据绑定一个变量，要用[]把数据框起来。例如写一个图片时，我们从后台拿出图片的Url数据，则需要用对img标签这么操作一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ts部分声明变量</span><br><span class="line">  public ImgUrl:any = &#x27;www.picurl.com&#x27;</span><br><span class="line"></span><br><span class="line">  //html部分</span><br><span class="line">  &lt;img [src]=&quot;ImgUrl&quot; alt=&quot;一个图片&quot; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-07&amp;08数据库相关</title>
      <link href="/2022/06/09/ISS-07&amp;08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/06/09/ISS-07&amp;08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>##关系数据库访问控制##<br>采用贝拉模型思想，为信息和用户分别分配安全等级<br>####隐蔽信道####<br>存在某个渠道本不该用来传递信息，现在却用来传递信息，这就是隐蔽信道<br>场景：不同等级事务同步可能产生隐蔽信道，多实例有助于防止隐蔽信道<br>####关系数据库的自主访问授权####<br>使用grant和revoke发放和回收<br>否定式授权:GRANT NODELETE ON emp TO bob<br>若授权冲突，否定优先于肯定，且个体优先于小组<br>普通授权：保护数据库数据。<br>系统级授权：保护数据库模式。<br>例如创建表、删除表、增加字段、删除字段、创建用户、删除用户、建立会话、改变会话、创建触发器、执行存储过程<br>####基于视图的访问控制####<br>作用：支持基于内容的访问控制，低层数据与高层策略间的独立性<br>不足：视图多，实现和维护复杂<br>####基于角色的访问控制####<br>基本思想：给工作岗位发放访问控制授权，给用户分配工作岗位，用户享有工作岗位的授权。<br>把工作岗位抽象成角色，就是RBAC模型 角色是权限的集合 这个访问控制模型就是<strong>RBAC</strong>模型<br>####数据库的推理方法####<br>1.借助求和结果进行推理<br>2.借助记录个数进行推理<br>3.借助平均值进行推理<br>4.借助中位数进行推理<br>5.借助智能填充进行推理<br>6.借助线性特性进行推理<br>推理控制常用隐藏法：<br>结果合并式隐藏法<br>把已生成的统计查询结果按一定方式合并后再提供给查询者<br>随机抽样式隐藏法<br>从数据库中抽取一个随机样本数据集，在样本数据集上查询生成结果。<br>偏差导入式隐藏法<br>给数据库中的数据项添加随机噪声，形成加噪数据集，在加噪数据集上查询生成结果。<br>##数据库强制访问控制##<br>主要使用的OLP模型，OLP模型是基于贝拉模型的访问控制模型<br>基于标签的读：如果用户U想要访问数据D，U的等级必须完全支配D的等级，如果D包含组别和类别，U至少含D中一个组别而且有授权，并且包括D中所有类别，否则拒绝访问<br>基于标签的写：如果用户U想要访问数据D，U的等级要完全支配D的等级，并且D的等级要完全支配U的最小等级；若D含组别，则U至少包括D中任意一个组别且有写的权限，且若含类别,U要有D中所有类别的读权限；若D不含组别，且有类别，U要有D中所有类别并且有写权</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-07&amp;08数据库相关</title>
      <link href="/2022/06/09/ISS-07-08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/06/09/ISS-07-08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="关系数据库访问控制"><a href="#关系数据库访问控制" class="headerlink" title="关系数据库访问控制"></a>关系数据库访问控制</h2><p>采用贝拉模型思想，为信息和用户分别分配安全等级</p><h2 id="隐蔽信道"><a href="#隐蔽信道" class="headerlink" title="隐蔽信道"></a>隐蔽信道</h2><p>存在某个渠道本不该用来传递信息，现在却用来传递信息，这就是隐蔽信道<br>场景：不同等级事务同步可能产生隐蔽信道，多实例有助于防止隐蔽信道</p><h2 id="关系数据库的自主访问授权"><a href="#关系数据库的自主访问授权" class="headerlink" title="关系数据库的自主访问授权"></a>关系数据库的自主访问授权</h2><p>使用grant和revoke发放和回收<br>否定式授权:GRANT NODELETE ON emp TO bob<br>若授权冲突，否定优先于肯定，且个体优先于小组<br>普通授权：保护数据库数据。<br>系统级授权：保护数据库模式。<br>例如创建表、删除表、增加字段、删除字段、创建用户、删除用户、建立会话、改变会话、创建触发器、执行存储过程</p><h2 id="基于视图的访问控制"><a href="#基于视图的访问控制" class="headerlink" title="基于视图的访问控制"></a>基于视图的访问控制</h2><p>作用：支持基于内容的访问控制，低层数据与高层策略间的独立性<br>不足：视图多，实现和维护复杂</p><h2 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h2><p>基本思想：给工作岗位发放访问控制授权，给用户分配工作岗位，用户享有工作岗位的授权。<br>把工作岗位抽象成角色，就是RBAC模型 角色是权限的集合 这个访问控制模型就是<strong>RBAC</strong>模型</p><h2 id="数据库的推理方法"><a href="#数据库的推理方法" class="headerlink" title="数据库的推理方法"></a>数据库的推理方法</h2><p>1.借助求和结果进行推理<br>2.借助记录个数进行推理<br>3.借助平均值进行推理<br>4.借助中位数进行推理<br>5.借助智能填充进行推理<br>6.借助线性特性进行推理<br>推理控制常用隐藏法：<br>结果合并式隐藏法<br>把已生成的统计查询结果按一定方式合并后再提供给查询者<br>随机抽样式隐藏法<br>从数据库中抽取一个随机样本数据集，在样本数据集上查询生成结果。<br>偏差导入式隐藏法<br>给数据库中的数据项添加随机噪声，形成加噪数据集，在加噪数据集上查询生成结果。</p><h2 id="数据库强制访问控制"><a href="#数据库强制访问控制" class="headerlink" title="数据库强制访问控制"></a>数据库强制访问控制</h2><p>主要使用的OLP模型，OLP模型是基于贝拉模型的访问控制模型<br>基于标签的读：如果用户U想要访问数据D，U的等级必须完全支配D的等级，如果D包含组别和类别，U至少含D中一个组别而且有授权，并且包括D中所有类别，否则拒绝访问<br>基于标签的写：如果用户U想要访问数据D，U的等级要完全支配D的等级，并且D的等级要完全支配U的最小等级；若D含组别，则U至少包括D中任意一个组别且有写的权限，且若含类别,U要有D中所有类别的读权限；若D不含组别，且有类别，U要有D中所有类别并且有写权</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-05&amp;&amp;06操作系统安全机制</title>
      <link href="/2022/06/09/ISS%2005&amp;&amp;06%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/06/09/ISS%2005&amp;&amp;06%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="用户划分的三分法与文件权限"><a href="#用户划分的三分法与文件权限" class="headerlink" title="用户划分的三分法与文件权限"></a>用户划分的三分法与文件权限</h2><p>属主：文件的拥有者。 属组：属主的首选用户组。 其余：除属主和属组之外的用户全体<br>属主域中只能有属主一个用户，其他两个的用户域都可以有多个用户。<br>例题：设在某UNIX操作系统中，部分用户组的配置信息如下：<br>    grp1:x:300:usr1,usr2,usr3,usr4<br>    grp2:x:301:usr5,usr6,usr7,usr8,usr9<br>系统中部分文件的权限配置信息如下：<br>    rw-r-x–x    usr1    grp1    …… File1<br>    r—w—x    usr5    grp2    …… File2<br>请问，用户usr1、usr2和usr5可以对文件file1执行什么操作？用户usr6可以对文件file2执行什么操作？<br>可对file1的操作：<br>usr1—属主—读和写；usr2—属组—读和执行；usr5—其余—执行。<br>可对file2的操作：usr6—属组—写。</p><blockquote><p>如果文件是自主访问控制，文件的属主可以修改文件的权限。换句话说，文件的属主可以对文件有任何权限。</p></blockquote><h2 id="和权限相关的进程问题"><a href="#和权限相关的进程问题" class="headerlink" title="和权限相关的进程问题"></a>和权限相关的进程问题</h2><p>如果执行程序权限有s，代表着进程变身，执行程序的时候会变为该权限对应的用户域<br>tips：excute是跳转执行，不会执行excute之后的语句</p><h2 id="访问控制中的特权"><a href="#访问控制中的特权" class="headerlink" title="访问控制中的特权"></a>访问控制中的特权</h2><p>在某种程度上，拥有特权可免受常规访问控制的约束。<br>特权是双刃剑：系统服务之所需，安全威胁之所在。<br>特权分离原则：财务权–出纳权+会计权<br>最小特权原则：杀鸡不要配牛刀<br>特权分离是实现最小特权原则的基础。<br>##文件加密##<br>为什么要加密？<br>文件离开操作系统的控制范围也不泄漏内容。<br>文件加密方法：<br>单个文件加密<br>整个磁盘加密<br>文件系统加密（目录树加密）</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-03系统安全基础&amp;04用户身份认证技术</title>
      <link href="/2022/06/08/ISS-03%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80&amp;04%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/06/08/ISS-03%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80&amp;04%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="纯软件的不足"><a href="#纯软件的不足" class="headerlink" title="纯软件的不足"></a>纯软件的不足</h2><p>可能会遭受程序的篡改和数据的泄露，安全会发成动摇 </p><h2 id="可信和信任"><a href="#可信和信任" class="headerlink" title="可信和信任"></a>可信和信任</h2><p>可信构造块：CPU RAM 控制器中的引导ROM 可插拔设备<br>可信平台模块TPM</p><h2 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h2><p>基于口令的身份认证:静态口令，动态口令<br>质询-响应式身份认证：质询问题生成 社交网络，隐私，专业知识&amp;&amp;响应：问题回答<br>基于生物特征的身份认证：指纹认证，人脸识别，虹膜识别<br>基于位置的身份认证</p><h2 id="口令处理方法"><a href="#口令处理方法" class="headerlink" title="口令处理方法"></a>口令处理方法</h2><p>增强口令字段生成：<br>1.用一个64位全0字符串的二进制位串构造成一个数据块Dp<br>2.K=用户的口令，i=0<br>3.Dc=Acrypt（K,Dp）<br>4.Dp=Dc,i=i+1<br>5.如果i小于25，回到第三步<br>6.S=Atrans(Dc)，取s 作为口令字段信息</p><p>撒盐算法：<br>1.把盐值附加在口令上：Dmp = Dpw || Dsalt<br>2.对生成的Dtmp进行哈希加密<br>3.Dhash作为返回结果</p><p>撒盐身份认证：口令字段生成–Agen（Dsalt，Dpw）<br>1.给口令使用撒盐算法，结果作为密钥K<br>2.和增强口令字段生成一样的过程 其中的K换成了撒盐算法生成的K</p><p>撒盐身份认证：口令字段维护<br>1.接受用户给的口令Dpw<br>2.生成一个盐值：Dsalt = Arandom（）<br>3.生成口令信息：S = Agen（Dsalt，Dpw）<br>4.将Dsalt和S存入数据库的口令字段中</p><h2 id="网络环境用户身份认证"><a href="#网络环境用户身份认证" class="headerlink" title="网络环境用户身份认证"></a>网络环境用户身份认证</h2><p>1.方案4.7<br>用户的期望：无论操控哪台计算机，只要以相同的身份登录，都能获得所需的服务<br>用户提供：账户信息+口令信息和身份认证请求，把请求发送给服务器后由服务器做身份认证<br>服务器做的：根据用户提供的账户信息和口令信息，结合身份认证信息数据库中的对应信息，判断账户和口令的合法性，再把结果返回给客户机<br>2.方案4.8<br>客户机和服务机都可以执行认证，根据用户确定哪些是由客户机执行，哪些是由服务器执行</p><p>密码体制：单钥密码体制和双钥密码体制，单是同一个密钥既加密也解密，双钥密码体制是公钥加密，私钥解密<br>数字签名是私钥签名，公钥验证，注意区别</p><p>互认证的加密机制<br>A给B发消息，用B的公钥加密会话密钥，然后再用A的私钥加密之前的加密结果 这样反过来解密的时候双方都可以很容易的获取到会话密钥</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISS-01绪论&amp;02经典模型</title>
      <link href="/2022/06/08/ISS-01%E7%BB%AA%E8%AE%BA&amp;02%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/06/08/ISS-01%E7%BB%AA%E8%AE%BA&amp;02%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="信息安全经典要素"><a href="#信息安全经典要素" class="headerlink" title="信息安全经典要素"></a>信息安全经典要素</h2><span id="more"></span><p>  机密性confidentiality</p><blockquote><p>机密性是指防止私密的或机密的信息泄露给非授权的实体的属性</p></blockquote><p>  完整性 Integrity</p><blockquote><p>完整性分为数据完整性和系统完整性，数据完整性指确保数据（包括软件代码）只能按照授权的指定方式进行修改的属性，系统完整性指系统没有受到未经授权的操控进而完好无损的执行预定功能的属性。</p></blockquote><p> 可用性 availability</p><blockquote><p>可用性是指确保系统及时工作并向授权用户提供所需服务的属性</p></blockquote><h2 id="安全策略和安全模型"><a href="#安全策略和安全模型" class="headerlink" title="安全策略和安全模型"></a>安全策略和安全模型</h2><p>安全策略：安全策略是指关于允许什么和禁止什么的规定。（安全策略是给人看的）<br>安全模型：安全模型是指用更加形式化的或数学化的术语对安全策略的重新表述。（安全模型是给计算机看的）</p><h2 id="DAC-自主访问控制"><a href="#DAC-自主访问控制" class="headerlink" title="DAC 自主访问控制"></a>DAC 自主访问控制</h2><p>允许某个主体显式地指定其他主体对该主体所拥有的信息资源是否可以访问以及可执行的访问类型。例如iphone手机的权限管理就是DAC自主访问控制。</p><h2 id="MAC-强制访问控制"><a href="#MAC-强制访问控制" class="headerlink" title="MAC 强制访问控制"></a>MAC 强制访问控制</h2><p>根据客体中信息的敏感标记和访问敏感信息的主体的访问级对客体访问实行限制。<br>我的定义：如果一个系统中只有系统才能对客体进行访问控制，用户自己不能改变这种控制，这就是强制访问控制。<br>换成安全策略和安全策略管理员同理。</p><h2 id="贝拉模型"><a href="#贝拉模型" class="headerlink" title="贝拉模型"></a>贝拉模型</h2><p>构成：简单安全特性（ss-特性）,星号安全特性（*-特性）,自主安全特性(ds-特性)和一个基本安全定理<br>以下中，f表示安全级别,&gt;=表示支配关系,f-c表示当前安全级别<br>简单安全特性：f(sub)&gt;=f(Obj)</p><p>星号安全特性:<br>1.若acc是r,则f-c(Sub)&gt;=f(obj)<br>2.若acc是a,则f(obj)&gt;=f-c(Sub)<br>3.若acc是w,则f(obj)=f-c(Sub)</p><p>自主安全特性：<br>acc一定在访问控制矩阵M中</p><p>基本安全定理：<br>如果系统每次变化都满足上述三个特性的要求，则系统的安全性一定不会被破坏</p><h2 id="毕巴模型"><a href="#毕巴模型" class="headerlink" title="毕巴模型"></a>毕巴模型</h2><p>毕巴模型是完整性访问模型，也是强制访问模型<br>绝对支配：&gt; 支配:&gt;=<br>写规则：主体S支配客体O<br>执行规则：主体S1支配主体S2<br>低水标模型读规则：imin = min(i(S),i(O))，那么，不管完整性级别如何，S都可以读O，但是，“读”操作实施后，主体S的完整性级别被调整为imin。<br>环模型读规则：不管完整性级别如何，任何主体都可以读任何客体。</p><h2 id="TE模型和DTE模型"><a href="#TE模型和DTE模型" class="headerlink" title="TE模型和DTE模型"></a>TE模型和DTE模型</h2><p>TE模型不足：<br>访问控制权限的配置比较复杂<br>二维表结构无法反映系统的内在关系<br>控制策略的定义需要从零开始<br>DTE模型特点：<br>使用高级语言描述访问控制策略<br>采用隐含方式表示文件安全属性<br>功能：类型描述 类型赋值 域描述 初始域设定 </p><h2 id="默克尔树模型"><a href="#默克尔树模型" class="headerlink" title="默克尔树模型"></a>默克尔树模型</h2><p>摆烂 就记住公式：f(i,i,D) = h(Di) f(i,j,D) = h(f(i,(i+j-1)/2,D) || f((i+j+1)/2,j,D)</p>]]></content>
      
      
      <categories>
          
          <category> 信息系统安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息系统安全 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANTD的选择框下拉绑定和查询问题</title>
      <link href="/2022/04/17/%E5%85%B3%E4%BA%8Eantd%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E6%A1%86%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E6%88%90%E5%8A%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/17/%E5%85%B3%E4%BA%8Eantd%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E6%A1%86%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E6%88%90%E5%8A%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>在使用a-select的时候发现下拉框的内容在绑定的v-model是item.id时使用搜索框自带的show-search的搜索功能会导致搜索出来的字段是id，而不是根据a-selection里的item.name字段正常显示：</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-select</span></span></span><br><span class="line"><span class="tag"><span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span></span></span><br><span class="line"><span class="tag">@<span class="attr">change</span>=<span class="string">&quot;Onchange&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">show-search</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-decorator</span>=<span class="string">&quot;[&#x27;State&#x27;]&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a-selection</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-for</span>=<span class="string">&quot;(item,index) in List&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">&#123;item.name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-selection</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><blockquote><p>使用：filter-option配置：</p></blockquote><p>在select里添加filter-option字段，并且在script文件里做出如下方法声明</p><p>Html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-select</span></span></span><br><span class="line"><span class="tag"><span class="attr">:filterOption</span>=<span class="string">&quot;filterOption&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span></span></span><br><span class="line"><span class="tag">@<span class="attr">change</span>=<span class="string">&quot;Onchange&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">show-search</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-decorator</span>=<span class="string">&quot;[&#x27;State&#x27;]&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a-selection</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-for</span>=<span class="string">&quot;(item,index) in List&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">&#123;item.name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-selection</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 将输入的内容与显示的内容进行匹配</span></span><br><span class="line">    filterOption (value, option) &#123;</span><br><span class="line">      <span class="keyword">return</span> option.<span class="property">componentOptions</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">text</span>.<span class="title function_">indexOf</span>(value) &gt;= <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>成功解决</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> antdv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
