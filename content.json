{"pages":[],"posts":[{"title":"vue常用指令、事件修饰符和自定义指令","text":"常用指令及作用v-on 用来给目标元素绑定事件的，事件的类型由参数决定。接下来，将举一个v-on用法的小例子: 1&lt;button v-on:click=&quot;clickHandler&quot;&gt;点击&lt;/button&gt; 当然 这里一般简写成 1&lt;button @click=&quot;clickHandler&quot;&gt;点击&lt;/button&gt; v-bind 用来给属性绑定一个变量 123456789var app = new Vue({ el:'.app', data:{ url:&quot;https://www.baidu.com&quot;, }});&lt;div class=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;click me&lt;/a&gt;&lt;/div&gt; 当然也有简写 123&lt;div class=&quot;app&quot;&gt; &lt;a :href=&quot;url&quot;&gt;click me&lt;/a&gt;&lt;/div&gt; v-model v-if v-show v-for v-else 不解释了 太常用了 没那么常用的指令和作用v-text 用来绑定数据 12&lt;div&gt;{{name}}&lt;/div&gt;&lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt; 这俩显示的效果是一样的，但是v-text会把值的内容拿来替换所有div里的内容，如果div里有东西全部都不显示 v-html 绑定数据 和v-text的区别就是v-html可以解析标签安全性问题：容易被利用进行跨站脚本攻击 v-cloak 配合css，可以做到延迟加载并且不会出现插值语法 v-once 只加载一次 后面插值语法内容更新的时候不会发生改变，即只更新一次 v-pre 跳过vue节点的编译过程 事件修饰符1.prevent 阻止默认事件2.stop 阻止事件冒泡3.once 事件只触发一次4.capture 使用事件的捕获形式5.self 只有event.target是当前元素时才触发事件6.passive 事件的默认行为立即执行，无需等待回调或执行完毕 自定义指令函数式写个例子，看看就懂了 12345678910111213141516&lt;div v-big=&quot;n&quot;&gt;&lt;/div&gt;new Vue({ data(){ return { n:1, } }, directives:{ big(element,binding){ element.innerText = binding.value*10 //element是元素，即dom节点 //binding是绑定，一般使用binding.value 获取绑定的值 } }}) 指令所在的模板被重新解析的时候就会重新调用指令 对象式12345678910111213141516171819202122&lt;input fbind:value=&quot;n&quot;&gt;&lt;/input&gt;new Vue({ data(){ return { n:1, } }, directives:{ fbind:{ bind(element,binding){ //这里写绑定时需要进行的动作 } insert(element,binding){ //插入元素时需要进行的动作 } update(element,binding){ //更新时进行的动作 } } }}) 总结","link":"/2022/09/29/4SHM2ptWgjuslFop/"},{"title":"VUE中key的处理","text":"列表中使用keykey是vue将虚拟dom转化为真实dom的时候会把vue处理掉，所以看不见key 12345&lt;ul&gt; &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;index&quot;&gt; {{p.name}} -- {{p.age}} &lt;/li&gt;&lt;/ul&gt; 如果需要在person数组里前面添加一个数据，因为下标发生了改变，会发生数据错乱。 key的工作原理 和 diff算法对于初始数据 {id:’001’,name:’张3’,age:’18’},{id:’002’,name:’张4’,age:’18’},{id:’003’,name:’张5’,age:’18’}vue在拿到后生成了虚拟dom如下: 123&lt;li key=&quot;0&quot;&gt;张3-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;&lt;li key=&quot;1&quot;&gt;张4-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;&lt;li key=&quot;2&quot;&gt;张5-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt; 数据添加在数组头的时候，现在的数据是：{id:’004’,name:’张2’,age:’18’}{id:’001’,name:’张3’,age:’18’}{id:’002’,name:’张4’,age:’18’}{id:’003’,name:’张5’,age:’18’} 生成的新虚拟dom为： 1234&lt;li key=&quot;0&quot;&gt;张2-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;&lt;li key=&quot;1&quot;&gt;张3-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;&lt;li key=&quot;2&quot;&gt;张4-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt;&lt;li key=&quot;3&quot;&gt;张5-18 &lt;input type=&quot;text&quot;&gt; &lt;/li&gt; 但是vue不会直接将虚拟dom转化成真实dom，vue将新虚拟dom和旧的虚拟dom进行对比，通俗来讲流程是这样的：首先看新的虚拟dom的key=0的一行，发现key为0，回去旧dom判断key=0的是否存在，而这里是存在的；再观察dom里有两个节点，一个文本（张3-18）,一个input框，文本对比张3-18和张2-18，发现发生了改变，于是vue拿新数据覆盖了旧数据； 对比input节点发现一样（因为输入的数据在真实dom里，现在比对的是虚拟dom，在内存中）；对于对比结果不一致的，于是决定不复用；对于对比结果一致的，直接复用。 key的作用key是虚拟dom对象的标识，当状态中的数据发生变化的时候，vue会根据新数据生成新的虚拟dom，随后vue进行新的虚拟dom与旧的虚拟dom的对比，按照规则去和留。","link":"/2022/09/27/5gPRXWxmruWJqCeQ/"},{"title":"Angular学习笔记 --Chap6 路由","text":"配置路由在新建组件的时候选择add route 此时会发现多了一个app-routing.module，在这个文件里引入我们声明的其他组件，并且配置路由 123456789101112131415const routes: Routes = [ //格式是path:'路径名',component:组件名 { path:'home',component:HomeComponent },{ path:'news',component:NewsComponent },{ path:'product',component:ProductComponent },{ path:'**',//任意的路由，如果前面的都不能匹配，则和这个匹配 redirectTo:'homes' }] 配置路由后,在根组件下会有一个route-outlet的标签，此时我们访问/home时，home组件的内容就会出现在这个route-outlet标签里。换句话说，你路由到哪个组件，组件内容就会在根组件的route-outlet的位置显示。 使用a标签跳转1234// 安装snippet之后直接输入ng-routelink就可以了&lt;a routeLink=&quot;/home&quot;&gt;首页&lt;/a&gt; 实现选中特效1234567&lt;a routeLink=&quot;/home&quot; routeLinkActive=&quot;className&quot;&gt;首页&lt;/a&gt;//.css.className{ color:red;} 路由传值和动态路由Get传值123456789101112131415161718//A页面跳转到B页面//A页面的html//跳转到aid为key的页面&lt;a routeLink=&quot;/newsDetail&quot; [queryParams]=&quot;{aid:key}&quot;&gt;跳转到新闻详情&lt;/a&gt;//B页面接收值import { ActiveRoute } from '@angular/route'constructor(public route:ActiveRoute){}ngOnInit(){ this.route.queryParams.subscribe((result)=&gt;{ console.log(result) })} 动态路由传值123456789101112//路由配置页path:'newsDetail/:aid'//A页面的html&lt;a routeLink=&quot;['/newsDetail/',key]&quot;&gt;跳转到新闻详情&lt;/a&gt;//B页面的ts this.route.params.subscribe((result)=&gt;{ console.log(result) }) JS跳转1234import { Router } from '@angular/router'this.router.navigate(['/newsdetail/', '1234'])","link":"/2022/07/12/CD636bLcU1pXCKer/"},{"title":"Angular学习笔记 --Chap 1 常用命令与组件操作","text":"Angular目录分析Angular是以组件为核心的框架，做的开发大多是和组件相关。而组件开发大多是在组件名/src/app里进行开发。其中app-routing.module是用来配置路由,app.component.html是根组件页面,app.component.css是根组件样式表,app.module.ts是组件的根模块，告诉组件如何组装应用 src/assets常用来放置一些静态的数据，例如图片等 src/enviornment该目录下是环境的配置 favicon.ico是项目的图标icon index.html是项目的入口html文件 style.scss用来防止一些全局样式，按需写入 没加粗的表示没什么用 Angular常用命令创建一个新项目ng new xxx 创建一个新组件ng g c 组件名 or ng g c 目录文件夹/组件名 比如我想创建一个在components文件夹下、名为news的组件，我可以这么创建ng g c components/news 挂载后运行ng serve --open 输入以上代码后访问localhost:4000可以打开你写的网页，打开速度很快，修改代码之后直接保存代码，网页也会立刻把修改的内容呈现出来，响应的很快 创建一个新服务###ng g service serviceName or ng g service route/serviceName 开始写代码吧Angular定义的各个组件之间可以直接调用。例如我新建了一个news组件，又新建了一个home组件，我可以直接在home文件夹里的html模板里调用&lt;app-news&gt;&lt;/app-news&gt;标签来调用news组件。 Angular在定义数据的时候需要声明数据类型。public username:string = '王大锤' —- 字符串 public listName:any[]=['王大锤','李大锤','张大锤'] —- 数组_1 public arr=['1111','2222','33333']; —- 数组_2 public items:Array&lt;string&gt;=['我是第一个新闻','我是第二个新闻']; —- 数组_3 其中，数组有三种声明方式。推荐使用第一种。 Angular在定义任何变量的时候建议都设置变量类型，甚至包括方法的形参，不设置的话可能会报错。 123GetData(e:any){ return e;} Angular不同于其他框架，声明变量时应该声明在正在使用的组件的components.ts文件中的export出的OnInit()函数里，写在constructor函数的正上方。 12345678910111213141516export class NewsComponent implements OnInit { //变量声明在下方 public username:string = '王大锤' //这是构造函数，页面刚刚准备加载时候调用，是最先调用的函数 constructor() { } //页面初始化后调用，注意此时视图还没加载完成，无法完成dom操作 ngOnInit(): void { } //函数声明在这里 GetData(key:any){ return key; }} 组件操作（循环，if判断等）循环操作很简单，在加载了Angular对应插件后直接输入ngfor就可以完成 写出来是这样的 ngFor = &quot;let item of List;let key = index&quot; 其中key不是一定要声明的，List是数组名，就是我们在OnInit里定义的数组变量。 条件判断 1&lt;div *ngIf = &quot;true&quot;&gt;这是angular中的条件判断&lt;/div&gt; 注意了,Angular没有ngElse 至少Angular7没有 所以需要否定判断的自行加! 1&lt;div *ngIf = &quot;!false&quot;&gt;这是angular中的else条件判断&lt;/div&gt; 如果想要让数据绑定一个变量，要用[]把数据框起来。例如写一个图片时，我们从后台拿出图片的Url数据，则需要用对img标签这么操作一下 12345//ts部分声明变量 public ImgUrl:any = 'www.picurl.com' //html部分 &lt;img [src]=&quot;ImgUrl&quot; alt=&quot;一个图片&quot; /&gt;","link":"/2022/07/07/GxVKBgUYIwmThpXh/"},{"title":"ISS-01绪论&amp;02经典模型","text":"信息安全经典要素 机密性confidentiality 机密性是指防止私密的或机密的信息泄露给非授权的实体的属性 完整性 Integrity 完整性分为数据完整性和系统完整性，数据完整性指确保数据（包括软件代码）只能按照授权的指定方式进行修改的属性，系统完整性指系统没有受到未经授权的操控进而完好无损的执行预定功能的属性。 可用性 availability 可用性是指确保系统及时工作并向授权用户提供所需服务的属性 安全策略和安全模型安全策略：安全策略是指关于允许什么和禁止什么的规定。（安全策略是给人看的）安全模型：安全模型是指用更加形式化的或数学化的术语对安全策略的重新表述。（安全模型是给计算机看的） DAC 自主访问控制允许某个主体显式地指定其他主体对该主体所拥有的信息资源是否可以访问以及可执行的访问类型。例如iphone手机的权限管理就是DAC自主访问控制。 MAC 强制访问控制根据客体中信息的敏感标记和访问敏感信息的主体的访问级对客体访问实行限制。我的定义：如果一个系统中只有系统才能对客体进行访问控制，用户自己不能改变这种控制，这就是强制访问控制。换成安全策略和安全策略管理员同理。 贝拉模型构成：简单安全特性（ss-特性）,星号安全特性（*-特性）,自主安全特性(ds-特性)和一个基本安全定理以下中，f表示安全级别,&gt;=表示支配关系,f-c表示当前安全级别简单安全特性：f(sub)&gt;=f(Obj) 星号安全特性:1.若acc是r,则f-c(Sub)&gt;=f(obj)2.若acc是a,则f(obj)&gt;=f-c(Sub)3.若acc是w,则f(obj)=f-c(Sub) 自主安全特性：acc一定在访问控制矩阵M中 基本安全定理：如果系统每次变化都满足上述三个特性的要求，则系统的安全性一定不会被破坏 毕巴模型毕巴模型是完整性访问模型，也是强制访问模型绝对支配：&gt; 支配:&gt;=写规则：主体S支配客体O执行规则：主体S1支配主体S2低水标模型读规则：imin = min(i(S),i(O))，那么，不管完整性级别如何，S都可以读O，但是，“读”操作实施后，主体S的完整性级别被调整为imin。环模型读规则：不管完整性级别如何，任何主体都可以读任何客体。 TE模型和DTE模型TE模型不足：访问控制权限的配置比较复杂二维表结构无法反映系统的内在关系控制策略的定义需要从零开始DTE模型特点：使用高级语言描述访问控制策略采用隐含方式表示文件安全属性功能：类型描述 类型赋值 域描述 初始域设定 默克尔树模型摆烂 就记住公式：f(i,i,D) = h(Di) f(i,j,D) = h(f(i,(i+j-1)/2,D) || f((i+j+1)/2,j,D)","link":"/2022/06/08/ISS-01%E7%BB%AA%E8%AE%BA&02%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/"},{"title":"ISS-05&amp;&amp;06操作系统安全机制","text":"用户划分的三分法与文件权限属主：文件的拥有者。 属组：属主的首选用户组。 其余：除属主和属组之外的用户全体属主域中只能有属主一个用户，其他两个的用户域都可以有多个用户。例题：设在某UNIX操作系统中，部分用户组的配置信息如下： grp1:x:300:usr1,usr2,usr3,usr4 grp2:x:301:usr5,usr6,usr7,usr8,usr9系统中部分文件的权限配置信息如下： rw-r-x–x usr1 grp1 …… File1 r—w—x usr5 grp2 …… File2请问，用户usr1、usr2和usr5可以对文件file1执行什么操作？用户usr6可以对文件file2执行什么操作？可对file1的操作：usr1—属主—读和写；usr2—属组—读和执行；usr5—其余—执行。可对file2的操作：usr6—属组—写。 如果文件是自主访问控制，文件的属主可以修改文件的权限。换句话说，文件的属主可以对文件有任何权限。 和权限相关的进程问题如果执行程序权限有s，代表着进程变身，执行程序的时候会变为该权限对应的用户域tips：excute是跳转执行，不会执行excute之后的语句 访问控制中的特权在某种程度上，拥有特权可免受常规访问控制的约束。特权是双刃剑：系统服务之所需，安全威胁之所在。特权分离原则：财务权–出纳权+会计权最小特权原则：杀鸡不要配牛刀特权分离是实现最小特权原则的基础。##文件加密##为什么要加密？文件离开操作系统的控制范围也不泄漏内容。文件加密方法：单个文件加密整个磁盘加密文件系统加密（目录树加密）","link":"/2022/06/09/ISS%2005&&06%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"},{"title":"ISS-03系统安全基础&amp;04用户身份认证技术","text":"纯软件的不足可能会遭受程序的篡改和数据的泄露，安全会发成动摇 可信和信任可信构造块：CPU RAM 控制器中的引导ROM 可插拔设备可信平台模块TPM 身份认证技术基于口令的身份认证:静态口令，动态口令质询-响应式身份认证：质询问题生成 社交网络，隐私，专业知识&amp;&amp;响应：问题回答基于生物特征的身份认证：指纹认证，人脸识别，虹膜识别基于位置的身份认证 口令处理方法增强口令字段生成：1.用一个64位全0字符串的二进制位串构造成一个数据块Dp2.K=用户的口令，i=03.Dc=Acrypt（K,Dp）4.Dp=Dc,i=i+15.如果i小于25，回到第三步6.S=Atrans(Dc)，取s 作为口令字段信息 撒盐算法：1.把盐值附加在口令上：Dmp = Dpw || Dsalt2.对生成的Dtmp进行哈希加密3.Dhash作为返回结果 撒盐身份认证：口令字段生成–Agen（Dsalt，Dpw）1.给口令使用撒盐算法，结果作为密钥K2.和增强口令字段生成一样的过程 其中的K换成了撒盐算法生成的K 撒盐身份认证：口令字段维护1.接受用户给的口令Dpw2.生成一个盐值：Dsalt = Arandom（）3.生成口令信息：S = Agen（Dsalt，Dpw）4.将Dsalt和S存入数据库的口令字段中 网络环境用户身份认证1.方案4.7用户的期望：无论操控哪台计算机，只要以相同的身份登录，都能获得所需的服务用户提供：账户信息+口令信息和身份认证请求，把请求发送给服务器后由服务器做身份认证服务器做的：根据用户提供的账户信息和口令信息，结合身份认证信息数据库中的对应信息，判断账户和口令的合法性，再把结果返回给客户机2.方案4.8客户机和服务机都可以执行认证，根据用户确定哪些是由客户机执行，哪些是由服务器执行 密码体制：单钥密码体制和双钥密码体制，单是同一个密钥既加密也解密，双钥密码体制是公钥加密，私钥解密数字签名是私钥签名，公钥验证，注意区别 互认证的加密机制A给B发消息，用B的公钥加密会话密钥，然后再用A的私钥加密之前的加密结果 这样反过来解密的时候双方都可以很容易的获取到会话密钥","link":"/2022/06/08/ISS-03%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80&04%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF/"},{"title":"ISS-07&amp;08数据库相关","text":"##关系数据库访问控制##采用贝拉模型思想，为信息和用户分别分配安全等级####隐蔽信道####存在某个渠道本不该用来传递信息，现在却用来传递信息，这就是隐蔽信道场景：不同等级事务同步可能产生隐蔽信道，多实例有助于防止隐蔽信道####关系数据库的自主访问授权####使用grant和revoke发放和回收否定式授权:GRANT NODELETE ON emp TO bob若授权冲突，否定优先于肯定，且个体优先于小组普通授权：保护数据库数据。系统级授权：保护数据库模式。例如创建表、删除表、增加字段、删除字段、创建用户、删除用户、建立会话、改变会话、创建触发器、执行存储过程####基于视图的访问控制####作用：支持基于内容的访问控制，低层数据与高层策略间的独立性不足：视图多，实现和维护复杂####基于角色的访问控制####基本思想：给工作岗位发放访问控制授权，给用户分配工作岗位，用户享有工作岗位的授权。把工作岗位抽象成角色，就是RBAC模型 角色是权限的集合 这个访问控制模型就是RBAC模型####数据库的推理方法####1.借助求和结果进行推理2.借助记录个数进行推理3.借助平均值进行推理4.借助中位数进行推理5.借助智能填充进行推理6.借助线性特性进行推理推理控制常用隐藏法：结果合并式隐藏法把已生成的统计查询结果按一定方式合并后再提供给查询者随机抽样式隐藏法从数据库中抽取一个随机样本数据集，在样本数据集上查询生成结果。偏差导入式隐藏法给数据库中的数据项添加随机噪声，形成加噪数据集，在加噪数据集上查询生成结果。##数据库强制访问控制##主要使用的OLP模型，OLP模型是基于贝拉模型的访问控制模型基于标签的读：如果用户U想要访问数据D，U的等级必须完全支配D的等级，如果D包含组别和类别，U至少含D中一个组别而且有授权，并且包括D中所有类别，否则拒绝访问基于标签的写：如果用户U想要访问数据D，U的等级要完全支配D的等级，并且D的等级要完全支配U的最小等级；若D含组别，则U至少包括D中任意一个组别且有写的权限，且若含类别,U要有D中所有类别的读权限；若D不含组别，且有类别，U要有D中所有类别并且有写权","link":"/2022/06/09/ISS-07&08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"},{"title":"ISS-07&amp;08数据库相关","text":"关系数据库访问控制采用贝拉模型思想，为信息和用户分别分配安全等级 隐蔽信道存在某个渠道本不该用来传递信息，现在却用来传递信息，这就是隐蔽信道场景：不同等级事务同步可能产生隐蔽信道，多实例有助于防止隐蔽信道 关系数据库的自主访问授权使用grant和revoke发放和回收否定式授权:GRANT NODELETE ON emp TO bob若授权冲突，否定优先于肯定，且个体优先于小组普通授权：保护数据库数据。系统级授权：保护数据库模式。例如创建表、删除表、增加字段、删除字段、创建用户、删除用户、建立会话、改变会话、创建触发器、执行存储过程 基于视图的访问控制作用：支持基于内容的访问控制，低层数据与高层策略间的独立性不足：视图多，实现和维护复杂 基于角色的访问控制基本思想：给工作岗位发放访问控制授权，给用户分配工作岗位，用户享有工作岗位的授权。把工作岗位抽象成角色，就是RBAC模型 角色是权限的集合 这个访问控制模型就是RBAC模型 数据库的推理方法1.借助求和结果进行推理2.借助记录个数进行推理3.借助平均值进行推理4.借助中位数进行推理5.借助智能填充进行推理6.借助线性特性进行推理推理控制常用隐藏法：结果合并式隐藏法把已生成的统计查询结果按一定方式合并后再提供给查询者随机抽样式隐藏法从数据库中抽取一个随机样本数据集，在样本数据集上查询生成结果。偏差导入式隐藏法给数据库中的数据项添加随机噪声，形成加噪数据集，在加噪数据集上查询生成结果。 数据库强制访问控制主要使用的OLP模型，OLP模型是基于贝拉模型的访问控制模型基于标签的读：如果用户U想要访问数据D，U的等级必须完全支配D的等级，如果D包含组别和类别，U至少含D中一个组别而且有授权，并且包括D中所有类别，否则拒绝访问基于标签的写：如果用户U想要访问数据D，U的等级要完全支配D的等级，并且D的等级要完全支配U的最小等级；若D含组别，则U至少包括D中任意一个组别且有写的权限，且若含类别,U要有D中所有类别的读权限；若D不含组别，且有类别，U要有D中所有类别并且有写权","link":"/2022/06/09/ISS-07-08%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"},{"title":"DOM","text":"DOM定义：Document Object Model，文档对象模型。用途：使用JS操作web页面。Document –&gt; 文档表示的是整个html网页文档Object –&gt; 将网页中的每一个部分都转化成了对象，例如标签，内容，都可以是对象。Model –&gt; 使用面向对象的方式操作对象 节点定义：node - 构成HTML文档最基本的单元常用有四类： -文档节点：整个HTML文档 -元素节点：HTML文档中的HTML标签 -属性节点：元素的属性 例如id name -文本节点：HTML标签中的文本内容 DOM操作 123456&lt;button id=&quot;btn&quot;&gt;这是一个按钮&lt;/button&gt;&lt;script&gt; var dom = document.getElementById('btn'); //修改按钮文字 dom.innerHTML = &quot;这是修改过的按钮&quot;&lt;/script&gt;","link":"/2022/07/26/M8GXOdNaXupXHGTA/"},{"title":"Angular学习笔记  --Chap4 生命周期函数与异步编程","text":"生命周期函数 生命周期函数就是在组件的状态发生改变，例如创建、更新、销毁时调用的一系列方法。Angular创建一个组件时，会调用如下的函数 constructor() : 使用简单的值对局部变量进行初始化，注意，这个函数并非生命周期函数 ngOnchange() : Angular接受数据绑定时调用 ngOnInit() : Angular第一次显示数据绑定和设置指令/组件的输入属性后调用。一般请求数据放在这里 ngDocheck() : 检测,在变更周期中调用。 ngAfterViewInit() : 初始化完视图之后调用。做dom操作可以放在这里。 ngAfterViewChecked() : 视图变更后调用 ngDestroy() : 组件销毁时调用 触发时机ngOnchange()在有父子传值的时候才会触发，如果没有父子组件通讯，ngOnchange()不会触发。几个check函数在数据绑定之后会再触发一次，举个例子 12345&lt;div&gt;{{title}}&lt;/div&gt;//ts文件public title:any = '这是一个title'; 在视图加载后进行title的数据绑定，会再触发一次三个check函数。所以如果console一下就可以发现，声明周期函数除了Onchange没触发一外全部触发一次之后，三个check函数还会再触发一次。中途如果数据改变了，几个check函数也会触发。 RXJS异步Angular引入RXJS的目的就是为了让异步变简单 使用observable12345678910111213import { observable } from 'rxjs';let stream = new Observable(observer =&gt;{ setTimeout(()=&gt;{ observer.next('get timeout data'); },2000)// 调用stream.subscribe(value =&gt;{ console.log(value)})}) 看上去和promise十分相似，实际上rxjs的功能更加强大。 超时取消订阅使用unsubscribe，超时后取消返回数据 12345678910111213GetRxjsData(){ let stream = new Observable(observer =&gt;{ setTimeout(()=&gt;{ observer.next('get timeout data'); },2000)}var stream = this.getRxjsData()var d = stream.subscribe((data)=&gt;{ setTimeout(()=&gt;{ d.unsubscribe(); },1000)}) 反复调用123456789101112getRxjsIntervalData(){ let count = 0; return new Observable(observer =&gt;{ setInterval(()=&gt;{ var name = 'good'+count; observer.next(name) },2000) }) })}console.log(this.getRxjsIntervalData()) Rxjs中的工具函数–map&amp;filter首先安装rxjs模块和导入map,filter 12npm install rxjs-compatimport {map,filter} from 'rxjs/operators'; filter123456789101112131415161718// 筛选出可以被2整除的valuegetRxjsIntervalData(){ let count = 0; return new Observable(observer =&gt;{ setInterval(()=&gt;{ var name = 'good'+count; observer.next(name) },2000) }) })}let stream = this.getRxjsIntervalData()stream.pipe( filter(val=&gt;val%2 == 0)).subscribe(value=&gt;{ console.log(&quot;filter&quot;+value)}) map1234567stream.pipe( map(value=&gt;{ return value*value;})).subscribe(value=&gt;{ console.log(&quot;map&quot;+value)})","link":"/2022/07/11/XugN5JDCzLhCKw0b/"},{"title":"Angular学习笔记 --Chap5 与服务器交互","text":"使用get请求数据首先在app.module中引入httpClientModule,然后在imports中声明 1234567import { httpClientModule } from '@angular/common/http';imports:[ HttpClientModule] 再在需要使用请求数据的地方引入httpclient与调用 1234567891011121314import { HttpClient } from '@angular/common/http';constructor(public http:HttpClient){}getData(){ let api = 'xxx' this.http.get(api).subscribe((result)=&gt;{ console.log(result) })} 使用POST提交数据大体和GET相同，但是POST需要多引入一个httpheader头文件,因为在进行POST请求的时候需要同时传一个header 1234567POSTDATA(){ let api = 'xxx' const httpOptions = {headers: new HttpHeaders({'content-type': 'application/json'})} this.http.post(api,{&quot;username&quot;:&quot;123&quot;,&quot;age&quot;:&quot;12&quot;},httpOptions).subscribe((response)=&gt;{ console.log(response) })} 使用jsonp获取服务器数据如果存在跨域，就使用jsonp来获取服务器数据。 首先，为什么会存在跨域？比如说域名是localhost，使用的协议是https，端口是5777，访问127.0.0.1:3000的服务器就会产生跨域。如果服务器不支持跨域，那么发出的GET或者POST请求都不可以获取到数据。只要协议、端口、域名有一个不一样，就属于不同源，那么访问时就可能产生跨域问题。 这里使用的解决方案是使用jsonp解决跨域问题解决的原理：jsonp相当于是通过callback的xxx方法把服务器的数据传回本地 如何判断服务器支不支持jsonp？在接口后写个callback = xxx 如果显示出了:xxx 说明支持jsonp 在app.module里引入 httpClientjsonModule 如下1234let api = 'xx'this.http.jsonp(api,'callback').subscribe((result)=&gt;{ console.log(result)}) 使用axios(第三方)来请求数据通过npm安装npm install axios --saveimport {axios} from 'axios'使用 12345678axiosGet(api){ //异步拿数据 axios.get(api) .then(function (response) { console.log(response) });}","link":"/2022/07/11/MaeISxN72jT02Gci/"},{"title":"Vue.set的详细分析和数据监测","text":"使用场景当实现定义好了data里的一组数据或者对象里的属性，后面想要添加新的属性或者新的对象的时候，可以使用Vue.set() 例如data里的student对象，如果想要添加一个sex属性，想当然可能会使用this.student.sex = 'male'这种赋值语句，但是这种赋值语句语句vue不会添加setter和getter函数，便不是响应式的，所以不会在页面中显示出来；可以使用Vue.set(this.student,'sex','male')来进行属性的添加 Vue.set() 是添加响应式属性target：需要向哪个目标对象添加 key：需要添加的属性名 val：需要添加的属性的值 注意事项不要向 vm实例对象中添加属性 或 直接向 vm._data 中添加属性说明白点 data里那么多数据， 不能直接添加到data的根路径里，只能用来添加到data里对象的属性里 对数组的数据监测vue规定，数组直接发生数据改变（意思就是直接等）不能调用监控push()、pop()、shift()、unshift()、splice()、sort()、reverse()Vue.set() 或 vm.$set()这些api可以调用数据监测，进一步更新到你的页面里 push在数组尾部添加一个数据，返回值是新的长度 pop在数组尾部删除一个数据，返回值是数组的最后一个元素 shift删除数组的第一个值，并且返回新的第一个值 unshift对数组的开头添加一个或更多元素，并返回新的长度 splicesplice(index,howmany,item1, …, itemX) 方法向/从数组中添加/删除项目，然后返回被删除的项目第一个参数：表示从哪个索引位置（index）添加/删除元素第二个参数：要删除的项目数量。如果设置为 0，则不会删除项目。第三个参数：可选。向数组添加的新项目 sort原列表进行排序，如果指定参数，则使用比较函数指定的比较函数 1234567function sortNumber (a, b) { return a - b}let arr = [10,5,40,25,1000,1]arr.sort(sortNumber)console.log(arr) // [1, 5, 10, 25, 40, 1000]123456 reverse反向处理","link":"/2023/02/28/cEUIRQynKYWg4IB2/"},{"title":"vue computed 和watch详细分析与使用","text":"computed如期名，computed是计算属性，被计算出来的属性官方文档中有这个例子 1234567891011121314151617&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } }}) 这里好像是method也可以完成需求，但是computed具有缓存属性，多次调用，vue会判断computed的依赖值是否修改，如果没有修改则只执行一次，后面会沿用这个结果；但是method是调用一次就会直接执行，造成资源浪费 computed监控的是自己定义的变量，比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化。这里的这个总金额使用computed属性来进行计算是最好的选择。 watchwatch主要是用来监控vue实例的变化，watch监视的数据必须在data里定义watch只能用来监听一个对象或者一个值，无法监控对象的一个属性watch 不支持缓存，数据变，直接会触发相应的操作watch 支持异步","link":"/2023/02/28/dNvnVBdwos4VWSrG/"},{"title":"Angular学习笔记 --Chap 2 双向数据绑定与服务","text":"事件和双向数据绑定事件Angular里提供了点击事件，写法和vue里大差不差，如下 1&lt;button (click)=&quot;getData($event)&quot;&gt;点击触发getData函数&lt;/button&gt; 如果想要加上监听，在括号中填入$event；这个getData方法写在module里的ngOnInit后面，方法之间不用加逗号 双向数据绑定步骤首先，双向数据绑定只是针对表单，想要使用双向数据绑定需要引入formsmodule，具体步骤如下 1.引入Formsmodule 1import { Formsmodule } from '@Angular/forms' 2.在想要使用双向数据绑定的地方写入ngmodel 12&lt;input type=&quot;radio&quot; value=&quot;1&quot; [(ngModel)]=&quot;gender&quot; id=&quot;male&quot;&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; value=&quot;2&quot; [(ngModel)]=&quot;gender&quot; id=&quot;female&quot;&gt;&lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; 注意：在select中使用双向数据绑定时写在select里 Angular中的服务什么是服务服务是公共的方法。组件A想要使用方法a,组件B也想要使用方法a，这时方法a就可以封装进一个服务里，组件A、B只需要对服务进行引入就可以了。 创建一个服务1ng g service serviceName 配置服务在app.module里的provider里写入服务名称,同时import一下,然后再在需要使用这个服务的地方引入该服务 1import {storageService} from './service/storage.service' 使用服务在需要使用的组件的module.ts文件里的构造函数中引入服务 1234constructor(public storage:storageService){ let serviceTest = this.storage.get()//get是在服务中声明的方法 console.log(serviceTest)}","link":"/2022/07/08/oBxcnSMUomsktSq3/"},{"title":"自定义正则表达式","text":"创建自定义正则表达式判断字符串里是否有aaa 12var reg = /aaa/console.log(reg.test('abc')) //false 如果字符太长，会影响整体美观，可以使用{num}来代替 12345678var reg = /a{3}/ //判断是否有3个avar reg1 = /ab{3}/ //判断是否有abbbvar reg2 = /(ab){3}/ //判断是否有abababvar reg3 = /ab{1,3}/ 判断是否有1个a+1到3个bvar reg4 = /ab{3, }/判断是否有1个a+3个以上的bconsole.log(reg.test('abc')) //false 检查是否由哪个字母开头或者结尾1234var reg = /^a/ //以a开头var reg = /a$/ //以a结尾var reg = /^a$/ //以a开头且以这个a结尾 换句话说是完全匹配正则表达式var reg = /^[0-9]/ //以数字开头","link":"/2022/07/26/lGbgvQJRtplLyffx/"},{"title":"web中页面缓存的使用方法","text":"LocalStorage特点LocalStorage是长期储存数据的方法，它拥有永久的生命周期,除非是主动删除数据,否则就算是关闭页面,localStorage保存的数据也不会消失。 使用方法LocalStorage有四个方法:储存数据setItem，删除数据removeItem，取出数据getItem，清除数据clear,下面列举几个常用情况 储存新数据使用setItem来储存数据 123// key为你保存再localStorage中这个玩意的名字，你取名叫王大锤就在localStorage里叫王大锤localStorage.setItem(key,JSON.stringify(value))//value是你要保存的值 因为localStorage仅支持存储字符类型的数据，所以先将可能为数组或对象的数据转化为JSON字符串，再进行存储。 获取数据使用getItem来获取数据 12//获取在localstorage里名字叫key的数据localStorage.getItem(key) 通常要将取出的数据JSON.parse一下把他变回原来的样子，所以一般这么写 1JSON.parse(localStorage.getItem(key) || '0') 修改数据其实就是修改后再存一遍，用setItem 代码我就不写了 删除数据使用removeItem 和取出一样 get换成remove就行 代码也不写了 SessionStorage特点sessionStorage 的生命周期是仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的 使用方法同localStorage 把localStorage换成sessionStorage就行 Cookie待施工","link":"/2022/07/08/qDdyTOpLgeugPVyT/"},{"title":"Angular学习笔记 --Chap 3 Dom操作与父子组件通讯","text":"Dom操作Angular中也可以对dom进行操作 使用原生js方法12345678//html&lt;div id=&quot;box1&quot;&gt;1234&lt;/div&gt;//ts 将id为box1的颜色变为红色ngAfterViewInit(){ var boxDom:any = document.getElementById('box1') boxDom.style.color = red} 使用Angular自带的dom操作12345678910111213141516171819202122232425//html&lt;div #Box1&gt; 我是一个叫做Box1的DOM节点&lt;/div&gt;//ts//头文件先引入import { viewchild } from '@angular/core'//在constructor上面构造@viewChild('Box1')Mybox:any;//还是在视图加载后的生命周期函数里进行dom操作，因为视图加载后dom才加载完成ngAfterViewInit(){ console.log(this.Mybox) //把box1的字体颜色变成红色 this.Mybox.nativeElement.style.color = &quot;red&quot;; //打印dom节点 console.log(this.Mybox.nativeElement.innerHTML);} 实际上，viewchild是父子组件之间通讯使用的工具，可以使用viewchild对子组件的方法进行访问 父子组件通讯父组件使用viewchild调用子组件里的方法在使用viewChild对整个子组件进行获取后，直接使用this.xxx就可以对整个子组件进行访问 123456@viewChild('Box1')Mybox:any;//使用getChild函数对子组件的run方法进行访问getChild(){ this.Mybox.run()} 父组件给子组件传值，使用input父组件(home)在调用子组件(header)的时候将自己的msg传到子组件，子组件再进行调用，例子如下 1234567891011121314151617181920//home组件的html//方法也可以直接这样传 [run]=&quot;run&quot; 子组件就可以直接使用run方法了//甚至可以把整个自己传过去 [home]=&quot;this&quot;&lt;app-header [title]=&quot;title&quot;&gt;我是header组件，也是子组件&lt;/app-header&gt;//home组件的tspublic msg:any='我是父组件的title'//header组件的ts 引入inputimport { Input } from 'Angular/core'//下面使用input@input()title:any;//header组件的html可以直接调用title，在ts里也可以用this直接调用&lt;div&gt;{{title}}&lt;/div&gt;//输出我是父组件的title","link":"/2022/07/08/xnZVKaU9ygUYNAn2/"},{"title":"ANTD的选择框下拉绑定和查询问题","text":"问题在使用a-select的时候发现下拉框的内容在绑定的v-model是item.id时使用搜索框自带的show-search的搜索功能会导致搜索出来的字段是id，而不是根据a-selection里的item.name字段正常显示： 123456789101112&lt;a-select placeholder=&quot;请选择&quot; @change=&quot;Onchange&quot; show-search v-decorator=&quot;['State']&quot; &gt; &lt;a-selection v-for=&quot;(item,index) in List&quot; v-model=&quot;item.id&quot; &gt; {item.name} &lt;/a-selection&gt; 解决方案： 使用：filter-option配置： 在select里添加filter-option字段，并且在script文件里做出如下方法声明 Html 12345678910111213&lt;a-select :filterOption=&quot;filterOption&quot; placeholder=&quot;请选择&quot; @change=&quot;Onchange&quot; show-search v-decorator=&quot;['State']&quot; &gt; &lt;a-selection v-for=&quot;(item,index) in List&quot; v-model=&quot;item.id&quot; &gt; {item.name} &lt;/a-selection&gt; JS 1234567891011&lt;script&gt;export default { methods: { // 将输入的内容与显示的内容进行匹配 filterOption (value, option) { return option.componentOptions.children[0].text.indexOf(value) &gt;= 0 } }}&lt;/script&gt; 成功解决","link":"/2022/04/17/%E5%85%B3%E4%BA%8Eantd%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E6%A1%86%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E4%B8%8D%E8%83%BD%E6%88%90%E5%8A%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"vue的生命周期","text":"初始化的整个流程1.初始化生命周期，事件 –&gt; 2.beforeCreate() –&gt; 3.初始化数据监测,数据代理 –&gt; 4.created()–&gt; 5.vue开始解析模板 生成虚拟dom –&gt; 6.beforeMount() –&gt; 7.内存中编译好的模板替换到浏览器的页面里 –&gt; 8. mounted() 发生update1.beforeUpdate():这一步执行的时候，页面中显示的数据还是旧数据，data里的数据是最新的，但是尚未同步。2.根据data中最新的数据在内存中重新渲染出一份最新的内存dom树，当最新的内存dom树被更新之后，把新的dom树渲染到真实页面中，完成了数据从data到view的更新updated():此时页面和data的数据已经保持了同步，都是最新数据 执行销毁1.beforeDestroy():vue进行到了销毁阶段，但是此时所有的data method都处于可用状态2.摧毁组件，事件监听3.destroyed():完全销毁，所有方法指令过滤器都不可用 生命周期发生的事件beforeCreate():这个时候，在实例被完成创建出来，el和data都没有初始化，不能访问data、method，一般在这个阶段不进行操作。 created():这个时候，vue实例中的data、method已被初始化，属性也被绑定，但是此时还是虚拟dom，真是dom还没生成，$el 还不可用。这个时候可以调用data和method的数据及方法，created钩子函数是最早可以调用data和method的，故一般在此对数据进行初始化。 beforeMount():此时模板已经编译完成，但还没有被渲染至页面中（即为虚拟dom加载为真实dom），此时el存在则会显示el。在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。当vue实例中，el为挂载目标，未对el进行定义，则this.el显示undefined，但页面中存在template也能识别挂载目标，因为template可以被看成占位符。如果对其进行定义则显示&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，故所以，beforeMount读取不了真实的el，在mounted才能读取到真实的el，因为el只有渲染完成后才会存在。这里讲的el是真实的el。在真实的el之前存在前，在beforeMount中的其实是页面中的#app，是挂载的目标。 mounted():此时模板已经被渲染成真实DOM，用户已经可以看到渲染完成的页面，页面的数据也是通过双向绑定显示data中的数据。 这实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的躺在我们的内存中，一动不动。 beforeUpdate():更新前状态（view层的数据变化前，不是data中的数据改变前），重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。只有view上面的数据变化才会触发beforeUpdate和updated，仅属于data中的数据改变是并不能触发。","link":"/2023/03/02/25mndVlvgeN3qP5X/"},{"title":"vue的组件与构造函数","text":"vue的组件声明定义组件: 12345678910111213141516const componentName = Vue.extend({ template:`&lt;div&gt;12345&lt;/div&gt;`//html data(){ //组件的data }})new Vue({ el:'#root'， data:{ }, components:{ componentName:componentName }}) const componentsName = vue.extend(options) 可以简写为 const componentsName = optiions vue组件嵌套定义在那里就在哪里引入 比较简单 单文件组件.vue结尾的文件引入别的组件：import里引入 然后在components里面注册 1234567891011//App.vue&lt;script&gt;import School from './School'export default { name:'App', components:{ School }}&lt;/script&gt; vueComponent前面定义的组件的本质（数据类型）到底是什么？组件的本质是VueComponent函数，是由vue.extend生成的。我们调用组件的时候，vue会帮我们调用vuecomponent函数。每次调用vue.extend的时候，都会调用一个全新的vueComponent vm和vc的区别vm是vue的实例对象，vc是组件的实例对象vm需要声明一个el 但是vc不需要vm的data必须是函数，所以才可以维护一份被返回对象独立的拷贝","link":"/2023/03/02/WwUBeygAXAwT78IC/"},{"title":"vue的props，mixin和插件","text":"props举一个实际情况的例子，APP.vue在调用你写的Hello.vue的时候，如果想要传入自己的值，有以下几种方法，体现组件是复用，但是数据是动态的 第一种 1234567891011121314//app.vue里&lt;hello name=&quot;AA&quot; sex=&quot;BB&quot; /&gt;//Hello.vue里export default{ name:''hello', data(){ return { msg:'123' } }, props:['name','sex']} 如果想传的值是数字，可以给传的属性前面加冒号 例如 :age 第二种（声明数据类型） 123456789101112131415161718//app.vue里&lt;hello name=&quot;AA&quot; sex=&quot;BB&quot; /&gt;//Hello.vue里export default{ name:''hello', data(){ return { msg:'123' } }, props:{ age:Number, name:String, sex:String }} 声明了数据类型，虽然区别不大，但是报错很明确 第三种（数据类型限制+默认值+是否必要限制） 1234567891011121314151617181920212223//app.vue里&lt;hello name=&quot;AA&quot; sex=&quot;BB&quot; /&gt;//Hello.vue里export default{ name:''hello', data(){ return { msg:'123' } }, props:{ name:{ type:String, required:true }, age:{ type:Number, default:99 //默认值 } }} 很好看懂，不多做解释了props优先级比data里的数据高，并且最好不要对props传来的数据进行修改，非要修改的话可以在data里声明一个替身，然后对其进行修改 mixin 混入作用就是两个组件使用同一个函数创建一个mixin.js 12345678// mixin.jsexport const mixinName = { method:{ showName(){ alert(this.name) } }} 在需要使用showName的函数的组件里先import这个mixin.js 12import {mixinName} from '../mixin.js'mixin:[mixinName] mixin的优先级低于data里的数据 如果想要所有的VC和VM 全局都使用这个mixin的话，直接在main.js里进行注册声明就好 123456//main.jsimport {mixinName1,mixinName2} from '../mixin'Vue.mixin(mixinName1)Vue.mixin(mixinName2) 插件plugins首先新建一个plugin.js文件在main.js里应用vue.use(plugins)可以在插件里声明全局过滤器，全局指令，全局混入，给vue的原型加方法","link":"/2023/03/03/H8GOknb5eAWff1Js/"},{"title":"vue中组件通讯(自定义事件和全局事件总线)","text":"子组件给父组件传值除了上篇提到的方法，还可以使用自定义事件的方法实现子组件和父组件的数据交互。在父组件里使用子组件的时候绑定一个v-on 例如下图 12345678910111213141516//App.vue&lt;student v-on:sendMessage=&quot;demo&quot; /&gt;demo(){ console.log('demo被调用了')}// student.vue&lt;button :click=&quot;sendStudentName&quot;&gt;点击&lt;/button&gt;sendStudentName(){ this.$emit('sendMessage') //打印出了上面的console.log} 这样使用，不需要声明props如果想传值，在emit里逗号隔开 还可以使用ref来代替v-on 12345678910111213141516171819//App.vue&lt;student ref=&quot;student&quot; /&gt;demo(){ console.log('demo被调用了')}mounted(){ this.$ref.student.$on('sendMessage',this.demo)}// student.vue&lt;button :click=&quot;sendStudentName&quot;&gt;点击&lt;/button&gt;sendStudentName(){ this.$emit('sendMessage') //打印出了上面的console.log} 绑定后的解绑在被调用的子组件里使用this.$off('eventName')解绑对应事件解绑多个事件 可以把多个事件放进数组里，一起解绑this.$off() 全部解绑 全局事件总线前面说的方法实现同级组件之间传值都太过繁琐，可以使用全局事件总线来达成这个目的。 123456789//main.jsNew Vue ({ el:'#app', render: h=&gt;h(app), beforeCreate(){ this.prototype.bus = this }}) 举个例子，比如说Student组件想要给School组件传值 ```//student组件里sendMessage(){ this.$bus.$emit(‘demo’,123123)} //school组件里mounted(){ this.$bus.$on(‘demo’,(data)=&gt;{ console.log(data) })}","link":"/2023/03/04/wWicEMeIsFCgzmqu/"},{"title":"vue中的代理配置","text":"跨域问题解决1.cors:后端同学来解决 2.jsonp:需要前端和后端人员一起来处理，有点麻烦 3.代理服务器 方式1：proxy:vue向服务器请求数据的时候，从向服务器请求改为向代理服务器请求数据，代理服务器的端口也是8080，这样vue在发送请求的时候就不是跨域发送请求了； 1234567// vue-config.jsdevServer: { proxy: '服务器地址'}//vue组件里axios.get('localhost:8080/student') 好像也不太好？缺点：1.不能配置多个代理2.如果public根目录下有同名文件 会先找public下的（开发中才会这样） 4.代理服务器 方式2： 1234567891011121314151617// vue-config.jsdevServer: { proxy: { '/api':{ target:'&lt;url&gt;', pathRewrite:{:'^/api':''} ws:true, changeOrigin: true, }, '/foo':{ target:'&lt;otherUrl&gt;' } }}//vue组件里axios.get('localhost:8080/student') 如果想要使用代理服务器，走的是api里的url，但是在访问的时候需要加上/api的前缀，写在端口号之后","link":"/2023/03/07/GBF6sW1rA61qrO8V/"},{"title":"nextick的用法","text":"nexticknextick所指定的回调会在dom节点更新后完成","link":"/2023/03/07/OEda78EeU38BCoD3/"},{"title":"Vue的插槽","text":"默认插槽插槽的作用：想要让父组件向子组件的指定位置插入Html结构，也是父子组件通讯的一种对于一个组件，如果想复用，同时又要满足不同的需求，例如如下场景：需要三个列表单组件 每个组件里面除了内容不同，其他要求都大致相同。组件1里需要有图片，组件2里需要有视频，组件3里需要有列表，可以使用插槽来解决这个问题。 12345678910//App.Vue&lt;category&gt;&lt;img src=&quot;&quot;&gt;&lt;/category&gt;//category.Vue&lt;div&gt;&lt;slot&gt;如果App.vue里category中间没东西，就会显示这行字，否则不显示这行字，显示中间的dom元素&lt;/slot&gt;&lt;/div&gt; 具名插槽 如果说还需要增加一个插槽，实现一一对应的结果，可以进行如下操作： 12345678910111213//App.Vue&lt;category&gt;&lt;img slot=&quot;center&quot; src=&quot;&quot;&gt;&lt;img slot=&quot;bottom&quot; src=&quot;&quot;&gt;&lt;/category&gt;//category.Vue&lt;div&gt;&lt;slot name=&quot;center&quot;&gt;如果App.vue里category中间没东西，就会显示这行字，否则不显示，显示中间的dom元素&lt;/slot&gt;&lt;slot name=&quot;bottom&quot;&gt;&lt;/slot&gt;&lt;/div&gt;name是center的img会被加载后放在了上面，name是bottom的img会被加载放在下面 作用域插槽数据在组件本身，但是根据数据生成的结构由父组件（即调用者决定） 1234567891011121314151617//App.Vue&lt;category&gt;&lt;template scope=&quot;scopeData&quot;&gt;&lt;ul&gt;&lt;li v-for=&quot;(item,index) in scopeData.names&quot; :keys=&quot;index&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt;&lt;/template&gt;&lt;/category&gt;//category.Vue&lt;div&gt;&lt;slot :names=&quot;names&quot;&gt;如果App.vue里category中间没东西，就会显示这行字，否则不显示，显示中间的dom元素&lt;/slot&gt;&lt;/div&gt;//names是category里的数据","link":"/2023/03/17/BZPCtneLVd8ppO98/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"信息系统安全","slug":"信息系统安全","link":"/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"},{"name":"信息安全","slug":"信息安全","link":"/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"antdv","slug":"antdv","link":"/tags/antdv/"}],"categories":[{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"信息系统安全","slug":"信息系统安全","link":"/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"},{"name":"vue","slug":"前端/vue","link":"/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"Angular","slug":"前端/Angular","link":"/categories/%E5%89%8D%E7%AB%AF/Angular/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"javascript","slug":"前端/javascript","link":"/categories/%E5%89%8D%E7%AB%AF/javascript/"}]}